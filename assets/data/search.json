[
  
   
      {
        "title"    : "µMotor",
        "category" : "",
        "tags"     : " elektronik, informatik, saison19",
        "url"      : "/blog/2018/umotor-treiber",
        "date"     : "May 5, 2018",
        "excerpt"  : "<p>Wir testen für die Saison 2019 schonmal einen neuen, intelligenten Motortreiber.\nEr ist uns beim Waschen leider etwas eingegangen. Funktioniert aber trotzdem noch.</p>\n\n",
        "content"  : "<p>Wir testen für die Saison 2019 schonmal einen neuen, intelligenten Motortreiber.\nEr ist uns beim Waschen leider etwas eingegangen. Funktioniert aber trotzdem noch.</p>\n\n<div class=\"jekyll-twitter-plugin\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">The first prototype of our next-generation motor controller &#39;µMotor&#39; is assembled and basically functional (LED is blinking!!).<br />One-cent coin for scale. <a href=\"https://t.co/db2JuhzwpL\">pic.twitter.com/db2JuhzwpL</a></p>&mdash; RoboterClub Aachen (@RCA_eV) <a href=\"https://twitter.com/RCA_eV/status/992582078163189761?ref_src=twsrc%5Etfw\">May 5, 2018</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</div>\n\n<div class=\"jekyll-twitter-plugin\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Photo of the back side of the board. <a href=\"https://t.co/ml8lta2A0r\">pic.twitter.com/ml8lta2A0r</a></p>&mdash; RoboterClub Aachen (@RCA_eV) <a href=\"https://twitter.com/RCA_eV/status/992882982213115904?ref_src=twsrc%5Etfw\">May 5, 2018</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</div>\n\n<div class=\"jekyll-twitter-plugin\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Bonus: 3D-printed SWD programmer adapter <a href=\"https://t.co/cxr7r0s5Mf\">pic.twitter.com/cxr7r0s5Mf</a></p>&mdash; RoboterClub Aachen (@RCA_eV) <a href=\"https://twitter.com/RCA_eV/status/992884250394406912?ref_src=twsrc%5Etfw\">May 5, 2018</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</div>\n"
      },
   
      {
        "title"    : "Saisonstart 2018",
        "category" : "",
        "tags"     : " eurobot, saison18",
        "url"      : "/blog/2017/saisonstart-2018",
        "date"     : "October 23, 2017",
        "excerpt"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n\n",
        "content"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n\n<p><img src=\"/assets/img/blog/robo_antrieb.jpg\" alt=\"\" /></p>\n\n<p>Wir haben schonmal einen neuen Allradantrieb konstruiert, hilf uns mit ihn zu bauen.</p>\n"
      },
   
   
   
     {
       
          "title"    : "Projekt: 3D-Drucker Octoprint",
          "category" : "Projekt",
          "tags"     : " software, 3d-druck",
          "url"      : "/projekt/3d-drucker-octoprint",
          "date"     : "June 5, 2018",
          "excerpt"  : "Einrichten und konfigurieren der Software Octoprint zum Betrieb des 3D-Druckers.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der 3D-Drucker soll an einen Raspberry angeschlossen werden, welcher mit der Software Octoprint [1] als Server fungiert und darüber den 3D-Drucker steuern kann.</p>\n\n<p>Primär soll das Drucken von den CAD-Workstations mit wenigen Klicks zu starten sein, ebenfalls ist es wünschenswert von jedem beliebigen PC oder Laptop Druckaufträge zu erteilen und zu überwachen.</p>\n\n<p>Weitere optional umsetzbare Features sind ein Touch-Display direkt am Drucker, eine Kamera-Überwachung im Druckergehäuse sowie eine gut sichtbare LED-Statusanzeige am Drucker.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Raspberry Pi</li>\n  <li>Linux</li>\n  <li>3D-Druck</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: 3dDrive",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/3d-drive",
          "date"     : "June 5, 2018",
          "excerpt"  : "3dDrive ist neues Konzept für ein Roboterfahrwerk, der in beliebige Richtung mit optimaler Beschleunigung fahren kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Differentialantrieb [1] ist der etablierte Stand der Technik im Eurobot.</p>\n\n<p>Im Differentialantrieb werden zwei Räder auf gleicher Achse mit zwei Motoren separat eingetrieben. Das Steuerprinzip ähnelt dem eines Panzers.\nNeben einfacher Steuerung und stabilen Fahrtverhalten zeichnet sich der Differentialantrieb durch eine kompakte (abgeschlossene) Bauweise und die Möglichkeit Odometrie für die Lokalisierung zu benutzen.</p>\n\n<p>Seitdem die Entwicklung eines globalen Positionierungssystem sich im Endstadium befindet, können Konzepte für neuartige Fahrwerke bewertet werden, z.B. 3dDrive. Bei dieser Antriebsart soll der Roboter drei Räder haben, die (ähnlich wie bei einem Einkaufswagen) frei verdreht werden können und angetrieben sind. Dadurch werden hohe Leistung und Manövrierfähigkeit erreicht.</p>\n\n<p>In Rahmen dieses Projektes soll der Konzept ausgebaut werden. Es sollen Mögliche Wirkprinzipien und Implementierungen bewertet werden. Ein Prototyp soll konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Motoren (2 Lenkung, 1 Antrieb)</li>\n  <li>Beschleunigung über 1g und Geschwindigkeiten bis 2.5 m/s</li>\n  <li>Modulare Bauweise</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD Entwicklung und Konstruktion</li>\n  <li>CAM</li>\n  <li>Auslegung mechanischer, elektrischer und evt. pneumatischer Komponenten</li>\n  <li>Entwicklung getriebetechnischer Komponenten für die Lenkung mit 2 Motoren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Aktorik für Spielelemente",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/aktorik",
          "date"     : "June 5, 2018",
          "excerpt"  : "Erfindung, Konstruktion und Fertigung von Greif-, Transport- und Lagersystemen für die Spielelemente der Saison 2019.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Im Eurobot-Wettbewerb müssen die Roboter regelmäßig verschiedene Objekte greifen, transportieren und nach bestimmten\nKriterien anordnen. Dazu sind kreative mechanische Lösungen notwendig, um die Aufgaben mit möglichst hoher\nGeschwindigkeit und Zuverlässigkeit innerhalb des eingeschränkten Bauraums der Roboter zu erledigen.</p>\n\n<p>Die Spielelemente waren in der Vergangenheit z.B. lackierte Holzbauklötze, Kunststoff-Zylinder, Bälle in verschiedenen\nGrößen und Materialien, Puks, CDs, Becher, Textilien, Flaschen  und ähnliches. Ähnlich zu industriellen\nAutomatisieungsaufgaben mussten diese innerhalb der 100 Sekunden eines Spiels oft an einer Stelle des Spielfelds\neingesammelt und an einer  anderen wieder abgelegt werden und dabei z.B. nach Größe oder Farbe sortiert, geschossen\noder gestapelt werden. Dabei ist es oft erstrebenswert, möglichst viele der Elemente in den Roboter zu laden und\ngemeinsam zu transportieren. Zum Handling können z.B. aktive oder passive Greifer, Walzen, Bänder, Ketten- oder\nSchienensysteme, Gebläse, Saugnäpfe, usw. verbaut werden.</p>\n\n<p>Die Spezifikationen der Spielelemente und die damit zu lösenden Aufgaben werden mit Veröffentlichung der Regeln der\nneuen Wettbewerbssaison im September 2018 bekannt.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Erfinden von kreativen mechanischen Konzepten</li>\n  <li>„Basteln“ von Prototypen aus Holz (und Heißkleber)</li>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Aluminium- (mit CNC-Fräse) oder 3D-Druck-Teilen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Alpha-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/alpha-motor",
          "date"     : "June 5, 2018",
          "excerpt"  : "Alpha-Motor ist eine Platine zur Ansteuerung von zwei Antriebsmotoren und momentan die Hauptplatine des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Alpha-Motor erfüllt mehrere Funktionen gleichzeitig: Ansteuern von ein oder zwei Motoren, etwa den Antriebsmotoen des Roboters, Odometrie und das Ausführen der Robotersoftware.</p>\n\n<p>Jede Platine verfügt dazu über ein Setup, das sowohl ein oder zwei DC- Motoren als auch ein oder zwei dreiphasige Brushless-DC Motoren unterstützt. Benötigt werden also sechs H-Brücken aus jeweils vier Leistungstransistoren, die von drei Brückentreibern kontrolliert werden. Das Herzstück ist dann der Mikrocontroller. Dieser steuert nicht nur die genannten Brückentreiber, sondern liest Motorencoder aus und kommuniziert über verschiedene Schnittstellen (vor allem CAN) mit dem Rest des Roboters. Zusätzlich wird durch den Mikrocontroller auf zwei Wegen der Strom in den Motoren überwacht: Eine grobe Strommessung über jeweils einen Shunt-Widerstand pro Motor und eine genauere die von Hall-Sensoren im eigenen Package durchgeführt wird. Zu guter Letzt dürfen Ausgänge und LEDs zu Debug-Zwecken auch nicht fehlen.</p>\n\n<p>Auf dem Microcontroller befinden sich neben den Motor-Reglern auch der Code, der den restlichen Roboter steuert. Die Befehle werden über CAN an die Peripherie (zum Beispiel die Motortreiberplatinen “Micro-Motor” oder andere Alpha-Motor-Platinen) weitergeleitet, aber andersrum können auch Sensordaten oder die Kommunikation mit dem Display hierüber ablaufen.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Phasen (DC und Brushless-DC Motoren)</li>\n  <li>ca. 20A pro Phase in der Spitze</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Mikrocontroller STM32F407</li>\n  <li>2x CAN-Bus mit 4 Steckern, 1 UART, 1 SPI/I2C</li>\n  <li>Anschlüsse für 4 AB-Encoder inklusive UART 1-Wire</li>\n  <li>Anschlüsse für 2 Hall-Sensoren</li>\n  <li>Strommessung und Strombegrenzung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: 49 x 77 mm²</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, Adc, Dac, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Battery Management System",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/batterie-management-system",
          "date"     : "June 5, 2018",
          "excerpt"  : "Das BMS (Battery Management System) ist im Roboter die zentrale Komponente für Stromversorgung und Verteilung.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboter wird von zwei möglich Stromquellen, einem externes Netzteil oder dem austauschbaren LiFe-Akku mit 6 Zellen, versorgt.</p>\n\n<p>Für die elektronischen Komponenten müssen 20..22V Motorspannung und eine Logikspannung von ca. 7V bereitgestellt werden, vom Eurobot-Regelwerk wird ein Notausschalter vorgeschrieben, welcher die Motorspannung deaktiviert.</p>\n\n<p>Außerdem muss die Akkuspannung überwacht werden um eine Tiefentladung zu verhindern sowie alle Ausgänge gegen Kurzschlüsse abgesichert werden.\nDies alles sind Aufgaben des BMS.</p>\n\n<h3 id=\"ideen\">Ideen</h3>\n<ul>\n  <li>Dauerbelastbarkeit &gt;5A, besser &gt;10A</li>\n  <li>7V Schaltregler (TI SimpleSwitcher LMZ14xxx)</li>\n  <li>Diskussionsbedarf: Schaltregler für konstante Motorspannung?</li>\n  <li>Integrierte Akku-Spannungsüberwachung</li>\n  <li>Integrierter Microcontroller mit CAN-Interface zum übermtteln der Akku-Zell-Spannungen</li>\n  <li>Mögliche Integration in einen Akku-Slot für passende Akku-Cases (siehe separate Projektbeschreibung)</li>\n  <li>Not-Aus Schalter nicht im Strompfad</li>\n  <li>Priorisierung des Netzteils falls Akku &amp; Netzteil angeschlossen sind</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design\n    <ul>\n      <li>Hochstrom-Design</li>\n    </ul>\n  </li>\n  <li>Akku-Spannungsüberwachung</li>\n  <li>Auslegung des Leistungselektronik</li>\n  <li>Ggf. Software für den Microcontroller</li>\n  <li>Aufbau und Inbetriebnahme des Projekts</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Biegebank",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/biegebank",
          "date"     : "June 5, 2018",
          "excerpt"  : "Konstruktion und Fertigung einer Biegebank.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub befindet sich im Besitzt einer gut ausgerüsteten Werkstatt, um mechanische Teile für die Roboter zu fertigen. Dazu gehören z.B. eine CNC-Fräse und ein 3D-Drucker.</p>\n\n<p>Jedoch müssen gebogene bzw. gekantete Bleche, die eine hervorragende Stabilität, Freiformbarkeit und ein geringes Gewicht besitzen, mit Schraubstock, Hammer, Holz und anderen improwisierten Werkzeugen gefertigt werden. Dabei sind die Biegewinkel und die Kantenlängen stark begrenzt.</p>\n\n<p>Um die Fertigung gebogener Teile zu ermöglichen, soll eine Biegebank konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Maximale Breite der Teile: 350mm</li>\n  <li>Mobil, z.B. durch eine einfache Klemmung am Tisch oder im Schraubstock</li>\n  <li>Ggf. verstellbare Blechdicke und Biegeradius</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Ggf. Rapid Prototyping mit 3D Drucker</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Ggf. werkstofftechniche Auslegung.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CAN to X",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/can-to-X",
          "date"     : "June 5, 2018",
          "excerpt"  : "Eine universal CAN-Platine mit der verschiedenste Sensoren an den CAN angeschlossen werden können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Viele Sensoren, die wir in der jeweiligen Season benötigen können ohne größeren Aufwand nicht direkt an den Roboter-CAN angeschlossen werden. Diese Universalplatine soll eine Anbindung vereinfachen. Das Herz der Platine wird ein STM32F303 gepaart mit einem CAN-Transceiver. Hauptsächlich muss bei diesem Projekt flexibele Software geschrieben werden um z.B. I2C oder aber SPI Sensoren einfach anzubinden. Auch soll die Funkkommunikation mittels NRF24L01 über diese Platine laufen.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>SPI</li>\n  <li>I2C</li>\n  <li>UART</li>\n  <li>CAN (Roboterclub-CAN)</li>\n  <li>Endschalter</li>\n  <li>LEDs</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Schaltplan-Entwurf</li>\n  <li>Platinendesign in KiCAD, Eagle oder Altium</li>\n  <li>SMD-Löttechnik</li>\n  <li>Software auf modm.io basierend in C++</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CNC Fräse Aufarbeiten",
          "category" : "Projekt",
          "tags"     : " werkzeug, mechanik",
          "url"      : "/projekt/fraese-aufarbeiten",
          "date"     : "June 5, 2018",
          "excerpt"  : "Die CNC Fräse wird samt Umhausung und Kühlschmiermittelkreislauf überholt.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub ist im Besitz einer CNC-Fräse vom Typ Haase Cut 2500M [1] aus dem Jahr 2008.\nHiermit fräsen wir den Großteil alles Bauteile für unsere Roboter aus Aluminium, Kunststoffen oder selten auch Holz.</p>\n\n<p>Die Umhausung der Fräse weist einige Probleme auf, welche behoben werden sollen um in Zukunft bequemes und sicheres Fräsen mit hochqualitativen Ergebnissen zu ermöglichen.</p>\n\n<p>Desweiteren gibt es viele kleine Aufgaben:</p>\n<ul>\n  <li>Für die Fräse liegt eine Werkzeuglängensensor bereit, welcher eingebaut und in der Software passend konfiguriert werden muss.</li>\n  <li>Der Filter im Kühlschmiermittelkreislauf ist schwer zugänglich, daher schwer zu leeren und zu klein. Daher soll der Kühlschmiermittelkreislauf konzeptionell überarbeitet werden und neu aufgebaut werden und der Kühlschmiermitteldurchfluss erhöht werden.</li>\n  <li>Ein Spritzschutz um den Fräser herum soll konstruiert und gebaut werden.</li>\n  <li>Das Gehäuse soll von innen vollständig mit 2K-EP-Harz abgedichtet werden.</li>\n  <li>Der Endschalter der X-Achse ist defekt und muss ersetzt werden.</li>\n  <li>Verbesserung der Aufspannvorrichtung für Platten.</li>\n  <li>Beschaffung oder Konstuktion und Bau eines Schraubstocks für kleine Bauteile.</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Schaltschrank aufbauen</li>\n  <li>Holz und Metallbearbeitung</li>\n  <li>LinuxCNC</li>\n  <li>Einweisung zur Bedienung der Fräse</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Camera-Recognition",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/camera-recognition",
          "date"     : "June 5, 2018",
          "excerpt"  : "Bildverarbeitungs Plattform für den Roboter bzw. externe Komponenten am Spielfeld.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bildverarbeitung hat im Rahmen des Eurobot vielseitige Einsatzzwecke.\nBevor/Neben der eigentlich Implementierung sollte eine möglichst standardisierte Schnittstelle für diverse zukünftige Einsatzzwecke  erstellt werden\nund wenn möglich Standard-Algorithmen vorbereitet werden.\nAm Beispiel der Spielregeln von 2018, ergeben sich zwei praktische Anwendungsfälle:</p>\n<ol>\n  <li>Die Erkennung eines aufgehängten Bauplanes auf dem Spielfeld (unabhängig von einem Roboter).</li>\n  <li>Zählen von Spielelementen (Klötze) in der Bauzone, zur Unterstützung/Optimierung einer Punkteschätzung.</li>\n</ol>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Recherche und Auswahl von Bildverarbeitungsalgorithmen</li>\n  <li>Definieren eines Framework</li>\n  <li>Auswahl Hardware-Plattform (Mikrocontroller bis embedPC, FPGA)</li>\n  <li>passende Auswahl Implementierungssprache</li>\n  <li>Ggfs. Einbindung vorhandener Libraries</li>\n  <li>Raspberry Pi + Kamera</li>\n  <li>Kommunikation/Anbindung über XPCC</li>\n</ul>\n\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver Hardware",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/debugserver-hardware",
          "date"     : "June 5, 2018",
          "excerpt"  : "Der Debugserver soll in den Roboter integriert werden um darüber kabellos den Roboter zu programieren, zu debuggen, fernzusteuern und die Log-Ausgaben aufzuzeichnen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Du entwirfst, planst und baust ein den speziellen Anforderungen (s.u.) gerechtes Erweiterungsboard für einen Raspberry Pi (“Pi HAT”) oder mit einem Raspberry Pi Compute Module (CM3) [1].</p>\n\n<p>Der primäre Einsatzzweck ist der Debugserver, allerdings ist es auch denkbar, dass die Hardware für die Hauptsteuerung genutzt wird.\nIn beiden Fällen ist absolute Zuverlässigkeit unerlässlich.</p>\n\n<p>Da die Anforderungen an mögliche Interfaces sich schnell ändern kann, wenn z.B. in Zukunft ein Laserscanner oder eine Kamera genutzt werden soll, sind viele universelle Anschlüsse am Board wünschenswert.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Raspberry Pi\n    <ul>\n      <li>Compute Module (CM3), Model 3 B+, Zero oder Zero W [2]</li>\n    </ul>\n  </li>\n  <li>WLAN 2.4GHz und 5GHz\n    <ul>\n      <li>Client und AP Modus umschaltbar</li>\n    </ul>\n  </li>\n  <li>STM32 Microcontroller über SWD programieren</li>\n  <li>CAN-Interface (2x) mit MCP2515 (Linux Treiber)</li>\n  <li>UART-Interface (min. 1x; RX only) zum Empfangen der Logs vom Mikrocontroller</li>\n  <li>Echtzeituhr (RTC) für Linux-Systemzeit</li>\n  <li>Batterie-Backup\n    <ul>\n      <li>Verzögertes, kontroliertes Herunterfahren</li>\n      <li>LiFe-Akku</li>\n      <li>Automatisches Akku-Laden über Roboterstrom</li>\n    </ul>\n  </li>\n  <li>Minimales intuitives UI (LEDs, Schalter/Taster)</li>\n  <li>Kleine Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>Recherche und Auslegung LiFe-Charger</li>\n  <li>Raspberry Pi und BCM2837</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Webmonitor",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung",
          "url"      : "/projekt/debugserver-webmonitor",
          "date"     : "June 5, 2018",
          "excerpt"  : "Entwicklung einer Web-Oberfläche zur aufbereiteten Anzeige des Debug-Logs des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum einfachen Debugging unserer Roboter-Software können im Programmcode der Microcontroller Log-Nachrichten erzeugt\nwerden, die per UART (serieller Schnittstelle) ausgegeben werden. Damit diese auch bei Testspielen ohne nervige Kabel\nzum Roboter verfolgt werden können, befindet sich auf den Robotern ein Raspberry Pi (der „Debugserver“), der unter\nanderem mit dem UART der Hauptplatine verbunden ist. Über eine Web-Anwendung soll der Log per WLAN anderen Computern mit\nWebbrowser zugänglich gemacht werden, wobei die Nachrichten in Echtzeit angezeigt und dabei grafisch aufbereitet\nwerden sollen.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Echtzeit-Anzeige der Log-Nachrichten (per Websocket oder AJAX-Polling)</li>\n  <li>Grafische Aufbereitung der Log-Nachrichten nach bestimmten Mustern (z.B. angegebene Softwarekomponente)</li>\n  <li>Modulare und dokumentierte Software zur einfachen Wartung und Erweiterung</li>\n  <li>Ggf. Filtern des Logs nach bestimmten Mustern (z.B. Zeitpunkt, Softwarekomponente, RegEx)</li>\n  <li>Aufzeichnung des Logs in eine Datei und Abruf alter Logs aus bestehenden Dateien</li>\n  <li>Ggf. Framework zur inhaltlichen Interpretation und übersichtlichen Darstellung bestimmter Nachrichtenformate,\nz.B. Übergänge in Zustandsautomaten, Plots von geloggten Werten, …</li>\n  <li>Ggf. Überwachung des Verbindungsstatus Browser → Debugserver, Debugserver → Microcontroller</li>\n  <li>Ggf. Funktionen wie Neustart, Flashen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Dynamische Web-Entwicklung mit einfachem Server in Python oder Ruby oder NodeJS</li>\n  <li>Entwicklung einer komplexen Singlepage-Anwendung in Javascript/ECMA-Script</li>\n  <li>Kommunikation per SocketIO-Library o.ä.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Driver",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/driver",
          "date"     : "June 5, 2018",
          "excerpt"  : "Entwicklung einer Softwarekomponente zur geregelten Ausführung von Fahrmanövern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Damit sich unsere Roboter kontrolliert auf dem Spielfeld bewegen können, sind Software-Routinen nötig, die verschiedene\nFahrmanöver ausführen und regeln können. Daher soll es eine Software-Komponente geben, die solche Routinen enthält und\nvon anderen Komponenten über eine definierte Schnittstelle mit Fahrmanövern beauftragt werden kann. Dabei kann es\nsich um die Rotation auf einen bestimmten Winkel, des Verfolgen einer Gerade oder eines Kreisbogens, die\ngeradlinige Anfahrt auf einen definierten Punkt, usw. handeln. Je nach Bewegungsart sind dazu unterschiedliche\ngeometrische Berechnungen, Regelungskonzepte und Sicherheitsfunktionen nötig.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Einheitliches Interface für verschiedene Fahrmanöver und Rückmeldung über Status und Fehler</li>\n  <li>Einfaches Interface zum Abfahren von Routen (Sequenzen von Fahrmanövern)</li>\n  <li>Einfache Fahrmanöver: Punkt anfahren, Gerade folgen, Kreisbogen folgen, Rotation</li>\n  <li>Komplexere Fahrmanöver: Nach Abstandssensor fahren, …</li>\n  <li>Modulare Software (DRY – Don’t Repeat Yourself), Dokumentation der Konzepte und Schnittstellen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwurf eines Software-Interfaces (in Abstimmung mit Entwicklern anderer Komponenten)</li>\n  <li>Entwicklung von Geometrieberechnungen und Positionsreglern</li>\n  <li>Softwareentwicklung in C++ mit XPCC und modm.io für Microcontroller</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Wettbewerb gewinnen",
          "category" : "Projekt",
          "tags"     : " eurobot",
          "url"      : "/projekt/win-the-eurobot",
          "date"     : "June 5, 2018",
          "excerpt"  : "Selbstverständlich ist das oberste Ziel natürlich den Eurobot sowohl in Deutschland, mindestens einem weiteren Land als Gast und auf dem internationalen Finale in Frankreich zu gewinnen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Einfach™ alles™ richtig™ machen™.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Platzierung: 1. Platz</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Gewinnen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fahrplattform Little",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/fahrplattform-little",
          "date"     : "June 5, 2018",
          "excerpt"  : "Konstruktion und Fertigung der Fahrplattform des kleinen Roboters für die neue Saison (2019).",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für unsere neuen Roboter für den Eurobot-Wettbewerb 2019 müssen Grundstruktur und Antrieb konstruiert und gefertigt\nwerden. Der kleine Roboter („Little“) soll mit einem Omnidrive-Antrieb [1] ausgerüstet werden. Durch diesen kann der\nRoboter sich in alle Richtungen bewegen. Die Grundkonstruktion wird aus einer gefrästen Aluminium-Bodenplatte bestehen,\nauf der die Lagerung der drei Omniwheels, die drei Antriebsmotoren, sowie der Aufbau des Roboters montiert werden.</p>\n\n<p>Im Gegensatz zu anderen Fahrplattformen sind keine Odometrieräder zur Positionsbestimmung vorgesehen. Stattdessen sollen\nUltraschall-Beacons und ggf. eine IMU [2] zur Orientierung verwendet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Geschwindigkeit 2 m/s</li>\n  <li>Kraft 50 N</li>\n  <li>Leistung 100 Watt</li>\n  <li>Motoren: 3x Maxon EC-max 30, Getriebe: 1:4,8</li>\n  <li>soll über Kanten von 3 mm fahren können</li>\n  <li>Räder Ø 50 mm</li>\n  <li>Bodenplatte Dicke ca. 10 mm\n    <ul>\n      <li>Motoren darin teilweise versenkt</li>\n    </ul>\n  </li>\n  <li>Umfang (nach Regeln 2018)\n    <ul>\n      <li>Startumfang        850 mm</li>\n      <li>Dynamischer Umfang 1050 mm</li>\n    </ul>\n  </li>\n  <li>Omnidrive (3 Räder)</li>\n  <li>IMU (inertial measurement unit) / Beschleunigungs- und Lagesensor [2]</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>3D-Druck zum Prototyping</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Simulation der Fahrdynamik (z.B. mit Matlab Simulink)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fernsteuerungs-GUI",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/python-gui",
          "date"     : "June 5, 2018",
          "excerpt"  : "Entwicklung einer Python/Qt-GUI-Anwendung zur Fernsteuerung und Diagnose unserer Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum Testen der Software- und Hardware-Komponenten unserer Roboter soll eine GUI-Anwendung für den Computer entwickelt\nwerden, die über Netzwerk und CAN-Bus mit der Steuerung der Roboter kommuniziert und einzelne Funktionalitäten gezielt\naufrufen kann. Ebenso soll sie verschiedene Zustände und Signale des Roboters zur Überwachung angezeigen und grafisch\naufbereiten.</p>\n\n<p>Dazu muss zunächst eine Python-Anbindung an unser Roboter-internes Kommunikations-Protokoll XPCC implementiert und die\nstrukturierte Beschreibung der Nachrichtenformate auf ein Python-Typensystem abgebildet werden. Dann können\nGUI-Anwendungen geschrieben werden: einerseits solche, die unabhängig von konkreten Problemstellungen dynamisch aus\nder strukturierten Beschreibung der Software-Komponenten erzeugt werden. Diese dienen dazu, ohne weiteren Aufwand neue\nFunktionalitäten der Robotersoftware zu testen und können auch bei anderen XPCC-basierten Projekten eingesetzt werden.</p>\n\n<p>Andererseits soll es Anwendungen mit auf bestimmte Aufgaben spezialisierten Userinterfaces geben, z.B. zur Fernsteuerung\ndes Roboterantriebs und anderer Motoren, zur Anzeige von gemessenen Sensorwerten, zum Konfigurieren der Strategie und\nStarten von Spielen, zur grafischen Anzeige der gemessenen Positionen eigener und gegnerischer Roboter auf dem\nSpielfeld, usw.</p>\n\n<h3 id=\"technische-datenfeatures\">Technische Daten/Features:</h3>\n<ul>\n  <li>Software in (pure) Python 3.x ohne Codegenerierung oder eigene native Bibliotheken</li>\n  <li>Modulare Struktur und gute Dokumentation zur einfachen Entwicklung von Fernsteueranwendungen oder anderen\nSoftware-Komponenten</li>\n  <li>Kommunikation mit den Robotern über XPCC-Protokoll via ZeroMQ</li>\n  <li>Dynamische erzeugte generische Benutzeroberfläche zur Steuerung und Diagnose beliebiger Software-Komponenten mit\nbeliebigen Parameter-/Datentypen</li>\n  <li>Komfortable Editoren für bestimmte Nachrichtenformate, z.B. Positionen auf dem Spielfeld</li>\n  <li>Framework zum einfachen Anlegen Saison-/Aufgabenspezifischer Oberflächen</li>\n  <li>Grafische Oberfläche zur Fernsteuerung der Roboterantriebe und zusätzlicher Motoren</li>\n  <li>Grafische Oberfläche zum Start des Roboters und zur Überwachung des Spielverlaufs</li>\n  <li>Grafische Oberfläche zum Debuggen und Kalibrieren der Odometrie</li>\n  <li>Grafischer Busmonitor zum Anzeigen aller oder bestimmter Bus-Nachrichten, als Rohdaten und interpretierte Werte\n(Vorbild: Wireshark)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Anwendungs-Entwicklung in Python 3.x</li>\n  <li>Entwicklung Grafischer Userinterfaces mit PyQt/Qt5</li>\n  <li>Auseinandersetzung mit den Software-Komponenten und der Kommunikation des Roboters</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Funk-Kommunikation XPCC-Backend",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/funk-komm-xpcc-backend",
          "date"     : "June 5, 2018",
          "excerpt"  : "Allgemeines und Standartisiertes XPCC-Backend über eine Funk-Schnittstelle.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Fuer die grundlegende Kommunikation im Roboter wird ein CAN-Bus verwendet.\nUm weitere Komponenten,\nwie etwa einen zweiten Roboter oder Positionierungsbaken des Gegners,\neinzubinden, muss eine Funk-Schnittstelle verwendet werden.\nEine bestehende Lösung ist bislang beschränkt auf zwei Roboter als Teilnehmer, die grundlegende Information für ihre Spielstrategie austauschen.\nIn diesem Projekt soll das XPCC-Protokoll, das zur Kommunikation verwendet wird,\num ein allgemeines Backend für eine Funk-Schnittstelle erweitert werden.\nDamit sollen beliebige externe Komponenten (zweiter Roboter, Gegnerbaken, externe Bildverarbeitung in Bakensystemen) eingebunden werden können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation\n    <ul>\n      <li>Phy-Layer: NRF24L01</li>\n      <li>Data-Link-Layer: MAC-Layer mit R2MAC (teil von XPCC)</li>\n    </ul>\n  </li>\n  <li>Softwareentwicklung in C++ mit modm.io und XPCC für Microcontroller</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: IMU (auch als Abschlussarbeit)",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/imu",
          "date"     : "June 5, 2018",
          "excerpt"  : "IMU für eine stabilere und effizientere Positionierung und Antriebsregelung.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Inertial Measurement Unit (Inertiale Messeinheit) [1] ist eine Kombination der Beschleunigungssensoren und Drehratensonseren.\nDiese sind meistens auf einer Platine bzw. Chip angebracht und ermöglichen eine Erfassung der Bewegung.\nDurch die Zeitliche Integration der Messwerte kann es auch auf die Geschwindigkeit und Position geschlossen werden.</p>\n\n<p>Eine IMU soll in unere Roboter mechanisch, elektrisch und software-technisch integriert werden.\nDadurch verbessern sich die Positionierung (Ein Filter für das globale Positionierungssystem) und die Antriebsregelung (Beschleunigungmessung für eine bessere Kontrolle in der Kurve).</p>\n\n<p>Dieses Projekt kann auch als eine Abschlussarbeit am Institus für Theoretische Informationstechnik (Fakultät 6) [2] gemacht werden.\nDie möglichen Themen wären: Kooperative Lokalisierung, Kalmanfilter.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>Kandidat: Bosch BNO055</li>\n  <li>Je 1 IMU auf unseren und gegnerischen Roboter</li>\n  <li>Integration mit dem globalen Positionierungssystem</li>\n  <li>Echtzeitfähigkeit für die Regelung</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Software-, Regler- und Filterentwicklung in C++ und z.B. Matlab</li>\n  <li>?..</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Intelligente Motor-Kommutierung",
          "category" : "Projekt",
          "tags"     : " elektronik, software",
          "url"      : "/projekt/motor-commutation",
          "date"     : "June 5, 2018",
          "excerpt"  : "Entwicklung einer intelligenten Kommutierungsmethode für Bürstenlose Gleichstrommotoren.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei den zumeist verwendeten Motoren handelt es sich um Bürstenlose Gleichstrommotoren (BLDC), welche von einem externen Steuergerät angesteuert werden müssen.</p>\n\n<p>Dieses Steuergerät enthält neben der Leistungselektronik auch noch Logik welche das vom Motor benötigte rotierende Magnetfeld erzeugt.</p>\n\n<p>Die einfachste und derzeit im RCA genutzte sogenannte Kommutierungsmethode ist die Block-Kommutierung.\nEs gibt Alternativen zur Block-Kommutierung, die u.a. Vorteile in den Punkten Kraft und Laufruhe bringen. Der Blog-Post [1] liefert hier ein erste Übersicht.</p>\n\n<p>Ziel diese Projektes ist die Evaluierung der Möglichkeiten sowie die Erstellung einer an die Bedürfnisse des RCA angepasste Simulation und idealerweise anschließende reale Implementation einer intelligenten Kommutierungslogik.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Software mit Echtzeit-Anforderung (Microcontroller)</li>\n  <li>STM32-Peripherie: Timer</li>\n  <li>Recherche und Dokumentation</li>\n  <li>Simulation mit geeigneter Toolchain</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Laserscanner-Positionierung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/laserscanner-positioning",
          "date"     : "June 5, 2018",
          "excerpt"  : "Entwicklung einer Software-Komponente zur Bestimmung der Roboterposition mit einem SICK-Laserscanner.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir besitzen einen SICK TIM 551 Laserscanner, der mittels eines Infrarotlasers radial Distanzen misst. In der richtigen\nHöhe in einen unserer Roboter eingebaut, wäre es damit prinzipiell möglich, die Roboterposition anhand der\nbeobachteten Entfernungen zum Spielfeldrand zu berechnen. Probleme machen dabei jedoch die Ausreißer durch im Lichtweg\nbefindliche Spielelemente, das Messrauschen, die zeitliche Latenz der Verarbeitung und die Verzerrung der Messungen bei\nBewegung des Roboters.</p>\n\n<p>Daher soll eine Software-Komponente entwickelt und in die Robotersoftware integriert werden, die die per Ethernet/UDP\nausgegebenen Daten des Laserscanners verarbeitet, daraus seine Position und Ausrichtung auf dem Spielfeld schätzt und\ndiese an die Robotersoftware übermittelt. Dort soll eine weitere Komponente die Positionsdaten entgegennehmen und unter\nbestimmten Voraussetzungen und Ausgleich der Zeitverzögerung die bekannte Roboterposition und -ausrichtung damit\nkorrigieren.</p>\n\n<p>Da für den Laserscanner bereits ein Treiber im Software-Framework ROS existiert, bietet es sich an, die Software zur\nPositionsberechnung ebenfalls in ROS zu entwickeln und die Daten anschließend über das XPCC-Protokoll an den\nMicrocontroller des Roboters zu senden.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Filterung der Messwerte (Tiefpass?)</li>\n  <li>Ausreißer-Elimination (z.B. RANSAC-Verfahren)</li>\n  <li>Überwachung der Roboterbewegung; Korrektur nur bei stehendem Roboter oder Entzerrung der Messung</li>\n  <li>Plausibilitätsprüfung der Positionen/Ausrichtungen vor Korrektur</li>\n  <li>Visualisierung der berechneten Daten zur Validierung des Verfahrens</li>\n  <li>Entwicklung als ROS-Node; zusätzliche Nodes zur Kommunikation mit dem Roboter</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Herleitung von Geometrische Berechnungen und Algorithmen</li>\n  <li>Entwicklung von Algorithmen zur Signalverarbeitung (Filterung, Ausreißeranalyse)</li>\n  <li>Software-Entwicklung für ROS in Python und/oder C++</li>\n  <li>Software für Microcontroller in C++ mit modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Micro-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/micro-motor",
          "date"     : "June 5, 2018",
          "excerpt"  : "Micro-Motor ist eine Platine zum Anschluss an CAN-Bus welche einen Motor ansteuern kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>In den Aktoren verbaute Motoren müssen angesteuert werden, dazu verfolgt der Micro-Motor das Konzept von verteilten Ansteuerungen.</p>\n\n<p>An jedem Motor wird unmittelbar eine kompakte Micro-Motor Platine montiert, welche gleichzeitig auch einen Magnetencoder [1] optional beinhaltet.\nDiese Platine wird über einen einzigen Stecker mit Strom und CAN-Bus versorgt und kann eigenständig den Motor ansteuern.\nZusätzlich kann ein Endschalter ausgelesen werden und die Temperatur des Motors überwacht werden.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare Pid-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten, welche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für AB-Encoder</li>\n  <li>optional Magnetencoder [1] auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, Adc, Dac, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/odometrie",
          "date"     : "June 5, 2018",
          "excerpt"  : "Implementierung von odometrischer Positionsbestimmung und einer Kalibrierungs-Routine",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs benutzen bislang Odometrie zur eigenen Lokalisierung auf dem Spielfeld. Dabei wird\nkontinuierlich aus der Drehbewegung zweier Räder die Robotergeschwindigkeit berechnet und damit die Position\nnachgeführt.</p>\n\n<p>In Rahmen dieses Projektes soll zunächst der Code für die Positionsbestimmung per Odometrie neu entworfen und\nprogrammiert werden und anschließend eine Routine zur einfachen Kalibrierung der Odometrie-Parameter entwickelt werden.\nDie neue Software-Struktur soll die Integration weiterer Positionierungsmethoden vorsehen, etwa die Ultraschall-basierte\nabsolute Positionierung (vgl. Projekt Ultraschall Lokalisierung) oder eine Inertiale Messeinheit (IMU).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Einarbeitung in die Roboterkinematik</li>\n  <li>Entwurf von Algorithmen zur Positionierung und Kalibrierung</li>\n  <li>Programmierung für eingebettete Systeme in C++ mit XPCC/modm Framework</li>\n  <li>Programmierung einer grafischen Anwendung in Python3/PyQt5</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie mit optischer Sensorik",
          "category" : "Projekt",
          "tags"     : " elektronik, software, mechanik",
          "url"      : "/projekt/odometrie-maussensoren",
          "date"     : "June 5, 2018",
          "excerpt"  : "Entwicklung eines optische Odometriesystems [1] für Roboterantriebe.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für den sich in Entwicklung befindenden Antrieb des kleinen Roboters basierend auf einem Omnidrive-Antrieb (siehe separate Projektbeschreibung) kann keine konventinelle Odometrie mit auf zwei zusätzlichen nicht angetriebenen Rädern genutzt werden.</p>\n\n<p>Ein vielversprechendes Konzept ist die Nutzung von Sensoren aus optischen Mäusen.</p>\n\n<p>Es gab im RCA bereits Versuche mit dem inzwischen abgekündigten und nur noch schwer erhältlichen Sensor ADNS9800 [2] von Avago.</p>\n\n<p>Idealerweise werden im Rahmen diese Projekts ein oder mehrere geeigneter Nachfolger ausfindig gemacht, die nötige Hardware aufgebaut, Software geschrieben und die Zuverlässig unter den Bedingungen des Eurobot-Wettbewerbs erprobt.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Latenz &lt;5ms</li>\n  <li>Auflösung X und Y: &lt;1mm</li>\n  <li>Auflösung Rotation: &lt;1° (ggf. mit mehreren Sensoren)</li>\n  <li>Kleine Bauform</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Recherche verfügbare Sensoren</li>\n  <li>Software</li>\n  <li>Test-Bench aufbauen</li>\n  <li>ggf. PCB Design</li>\n  <li>Datenanalyse und Aufbereitung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Roboter-Caddy",
          "category" : "Projekt",
          "tags"     : " mechanik, elektronik, software",
          "url"      : "/projekt/roboter-caddy",
          "date"     : "June 5, 2018",
          "excerpt"  : "Um die Roboter mit Zubehör, Baken, etc. bei den Wettbewerben zum Spielfeld zu transportieren wollen wir einen coolen Roboter-Caddy bauen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Langweilige Implementationen dieser Idee kann man bei anderen Team beobachten, wo die Roboter in Bollerwägen, Kisten oder Kinderwägen transportiert werden.</p>\n\n<p>Wir wollen das natürlich weniger langweilig haben, also mit einem Antrieb und Steuerung welche den Roboter-Caddy autonomer einer Person folgen oder sich fernsteuern lässt.</p>\n\n<h3 id=\"anforderungen\">Anforderungen</h3>\n<ul>\n  <li>Kompakte Bauform, leicht zu Wettbewerben zu transportieren\n    <ul>\n      <li>in Roboterkiste integriert</li>\n      <li>zusammenklappbar</li>\n      <li>o.ä.</li>\n    </ul>\n  </li>\n  <li>Robustes Fahrwerk für unebene Böden auf Wettbewerben</li>\n  <li>Leistungsstarker Antrieb</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Mechanik</li>\n  <li>Elektronik</li>\n  <li>Software</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Routing-Algorithmus",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/routing",
          "date"     : "June 5, 2018",
          "excerpt"  : "Entwicklung und Implementierung eines Routenfindungs-Algorithmus für die Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zur Navigation unserer Roboter auf dem Spielfeld soll ein Routing-Algorithmus entwickelt werden, mit dem jeder Roboter\nautonom die optimale Route zu einem Zielpunkt auf dem Spielfeld berechnen kann. Dabei sollen Hindernisse auf dem\nSpielfeld und nach Möglichkeit die aktuellen Positionen der anderen Roboter auf dem Feld mit Bezug auf die bekannten\nAußenmaße des Roboters berücksichtigt werden. Weiterhin sollte der Algorithmus die Einschränkungen des Antriebssystems\n(Bewegungs-Freiheitsgrade, max. Beschleunigung, etc.) berücksichtigen und möglichst einfach auf andere Antriebssysteme\n(z.B. Omnidrive) erweiterbar sein.</p>\n\n<h3 id=\"featuresideen\">Features/Ideen:</h3>\n<ul>\n  <li>A*-Algorithmus auf einem kartesischen Raster auf dem Spield mit ca. 30mm Auflösung, je 8 Ausrichtungen,\n8 Bewegungsrichtungen pro Feld</li>\n  <li>Dynamische Berechnung von Kantengewichten basierend auf Fahrtrichtungsänderungen und Antriebssystem</li>\n  <li>Vorabberechnung gesperrter Positionen/Ausrichtungen basierend auf Hindernissen und Roboterform</li>\n  <li>Online-Berechnung zusätzlich gesperrter Positionen/Ausrichtungen basierend auf Positionen anderer Roboter</li>\n  <li>Automatische Optimierung (Postprocessing) der Route durch Kurven und Geraden in beliebigen Winkeln</li>\n  <li>Ausführung auf einem separaten Microcontroller mit externem Speicher, Anbindung per CAN-Bus</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwicklung von Routing- und Geometrieverarbeitungs-Algorithmen</li>\n  <li>Ggf. Implementierung und Validierung von Algorithmus-Prototypen in Python o.ä.</li>\n  <li>Softwareentwicklung in C++ für Microcontroller</li>\n  <li>Integration in bestehende Robotersoftware mit modm.io und XPCC</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Sensorik zur Gewichtsmessung",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb, software, mechanik",
          "url"      : "/projekt/gewichtsmessung",
          "date"     : "June 5, 2018",
          "excerpt"  : "Aufbau eines Prototypen zur Gewichtsmessung von Spielelementen mit Roboterarmen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei der Ankündigung des Eurobot-Mottos für 2019 “Atom Factory” [1] wurde erwähnt, dass die Roboter Spielelemente wiegen sollen.\nAuch für einige andere Aktorik ist die Technologie hilfreich.</p>\n\n<p>Das Ziel des Projekts ist einen Prototyp einer Sensorik zur Gewichtsmessung für einen Roboterarm zu implementieren.</p>\n\n<p>Die verschiedenen möglichen Methoden zur Gewichtsmessung soll verglichen und für den Einsatz im Roboter bewertet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant</h3>\n<ul>\n  <li>Mögliche Methoden\n    <ul>\n      <li>Strommessung Elektromotor</li>\n      <li>Dehnungsmessstreifen [2]</li>\n      <li>Mechnisch mit Feder und Taster</li>\n      <li>Weitere [3]</li>\n    </ul>\n  </li>\n  <li>Präzison je nach Anforderungen</li>\n  <li>Kraft/Gewicht je nach Anforderungen</li>\n  <li>Platine zum Anschluss an CAN</li>\n  <li>Kompakte Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Analogelektronik</li>\n  <li>PCB Design</li>\n  <li>STM32</li>\n  <li>Software Mikrocontroller</li>\n  <li>Ggf. Mechanik</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Silikon-Räder",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/silikon-raeder",
          "date"     : "June 5, 2018",
          "excerpt"  : "Silikon hat für die Antriebsräder sehr geeignete Eigenschaften.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs werden von Motoren angetrieben welche ihre Kraft mit Hilfe von Rädern auf den Untergrund bringen.</p>\n\n<p>Dabei spielen die Räder eine entscheidenden Faktor wie präzise und schnell der Roboter fahren, beschleunigen und bremsen kann.\nJe größer die Haftung der Räder auf dem Untergrund ist, umso besser kann Kraft übertragen werden.</p>\n\n<p>Historisch wurden im RCA modifizierte Inline-Skater-Räder oder Modellbau-Räder verwendet, in letzter Zeit hat uns die Firma TYP AG / TGW GmbH mit nach unseren Vorgaben individuell angefertigten Rädern mit vulkanisiertem Gummi unterstützt.</p>\n\n<p>Für den kleiner Roboter der Saison 2016 wurden bereits Experimente mit Silikonrädern durchgeführt, der Ergebnis war ein voller Erfolg.</p>\n\n<p>Im Rahmen dieses Projektes soll die Technologie zum Gießen von Silikon im RCA erarbeitet und dokumentiert werden und in Folge dessen für mindestens einen der Roboter Antriebs-Räder aus Silikon hergestellt werden.</p>\n\n<p>Neben Antriebsrädern gibt es noch viele weitere Anwendungen für gegossene Silikon-Teile, beispielsweise bei Greifern.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Formen mit CNC-Fräse und/oder 3D-Drucker</li>\n  <li>Ggf. Kooperation mit einem Institut bzw. Silikonhersteller</li>\n  <li>Gießen von Silikon</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Software auf modm portieren",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/rca-projekte-auf-modm-portieren",
          "date"     : "June 5, 2018",
          "excerpt"  : "Erstellung einer Skripte-Sammlung, die das Portieren unserer Software Projekte vom xpcc.io Framework zur modm.io Library (halb-)automatisch ermöglicht.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir nutzen seit 2009 das xpcc.io Framework [1] als Basis für all unsere eingebettete Software.\nVon 2016 bis 2018 haben die zwei Hauptmaintainer Fabian und Niklas H. dieses generalüberholt\nund tiefgreifende Änderungen in der Code-Generierung und teilweise der Struktur/API gemacht,\num den Code modularer und insbesondere unabhängig vom Build System zu machen.</p>\n\n<p>Der Nachfolger von xpcc heißt jetzt modm [2]. \nxpcc wird noch bis Ende 2018 maintained und danach als deprecated markiert.\nBis dahin werden alle Änderungen von xpcc nach modm von Niklas H. portiert.</p>\n\n<p>Ein oder mehrere Skripte sollen entwickelt werden, die den Hauptteil der Änderungen\nvollautomatisch, oder zumindestens mit wenigen manuellen Eingriffen, anwenden.\nZusätzlich soll ein Porting Guide von xpcc auf modm für die Webseite geschreiben,\nsodass auch externe Anwender auf modm upgraden können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, Regex, Python3, SCons</li>\n  <li>Verständnis der Änderungen zwischen xpcc und modm</li>\n  <li>Code Generierung</li>\n  <li>Versionsverwaltung und CI</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Ultraschall Lokalisierung (Baken)",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/ultraschall-baken",
          "date"     : "June 5, 2018",
          "excerpt"  : "Unsere Roboter sollen sich mittels eines Ultraschall-Baken-Systems auf dem Spielfeld orientieren können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir wollen beim kommenden Wettbewerb ein neues System zu Lokalisierung und unserer eigenen sowie der Gegner-Roboter einsetzen.</p>\n\n<p>Das technische Konzept das Ultraschall-Lokalisierung wurde in den letzten Jahren bereits entwicket und getestet, eine gute Übersicht liefert das Paper [1].</p>\n\n<p>Dieses System muss nun in unsere Roboter und Gegner-Baken integriert, angepasst und getestet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Drei feste Baken am Spielfeldrand</li>\n  <li>Mobile Baken in den eigenen Robotern und in den Gegnerbaken</li>\n  <li>Geringe Latenz &lt;10ms</li>\n  <li>Genauigkeit &lt;5mm</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation mit R2MAC/NRF24L01+</li>\n  <li>Software\n    <ul>\n      <li>Portieren der Software zum modm-Framework</li>\n    </ul>\n  </li>\n  <li>ggf. PCB Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: librobots: Open Source Veröffentlichung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/librobots-open-source",
          "date"     : "June 5, 2018",
          "excerpt"  : "Vervollständigung und Veröffentlichung unserer internen librobots Bibliothek auf GitHub.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Es existiert recht viel Code, der jede Saison weiter benutzt wird, aber nicht \ngenerisch genug ist um in modm.io zu landen.\nDeshalb wurde angedacht, diesen Code in librobots zu überführen und dort als\neigenständiges Projekt zu warten und somit duplizierten Code zu vermeiden.\nDieses Projekt soll den Kern unserer modularen Robotersoftware werden, ähnlich\nwie xpcc bzw. modm der Kern unserer eingebetten Software ist.\nDemzufolge soll auch die enstehende Architektur dokumentiert werden.</p>\n\n<p>Dieses Projekt ist als “Ausbildung” zum Open Source Maintainer gedacht, und ist\nsomit als Langzeitprojekt konzipiert.\nDie librobot soll erstmal im internen GitLab für die Veröffentlichung vorbereitet\nwerden und dann unter der RCA GitHub Organisation [1] als Open Source Projekt \ngeführt werden.\nDie Prozesse (Issue Tracking, Code Review, CI, Dokumentation) sollen wenn möglich\nähnlich zu modm.io gehalten werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Open Source Library Maintainance</li>\n  <li>Issue Tracking and Code Review</li>\n  <li>Architecture Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Einheitensystem und Festkomma-Arithmetik",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-units-and-fixed-point",
          "date"     : "June 5, 2018",
          "excerpt"  : "Implementation eines Einheitensystem mit user-defined literals und in Kombination mit Festkomma-Arithmetik für das open-source C++-Microcontroller-Framework modm.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für alle physikalischen Berechnungen in unserer Robotersoftware wollen wir Einheiten nutzen können, dies sorgt für übersichtlicheren und besser selbst-dokumentierenden Code.</p>\n\n<p>Beispiel:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>using namespace modm::units;\nlength_t distance = 300_mm;\ntime_t   time     = 1500_ms;\nvelocity_t speed  = distance / time;\nfloat foo         = distance + time; // compiler error: Units are not compatible.\n</code></pre></div></div>\n\n<p>Da es auf Microcontrollern aus verschiedenen Gründen nicht erstrebenswert mit Gleitkommazahlen zu rechnen ist, bietet es sich an gleichzeitig Festkomma-Arithmetik [1] im <em>modm</em> zu implementieren.</p>\n\n<h3 id=\"diskussion--features\">Diskussion &amp; Features</h3>\n<ul>\n  <li>Fehlerabschätzung Multiplikation und Division</li>\n  <li>Unittests</li>\n  <li>Portieren und Anpassen bestehender Klassen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Nebenläufigkeits Modelle erforschen (Concurrency)",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-concurrency-modelle",
          "date"     : "June 5, 2018",
          "excerpt"  : "Erstellen eines Modells zur einfachen und sicheren Beschreibung von Nebenläufigkeiten (Concurrency) für eingebettete Systeme.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Um die Nebenläufigkeiten im Robotercode zu beschreiben nutzen wir Protothreads [1], Resumable Functions [2] und Activities [3].\nDiese basieren auf sog. stackless cooperative scheduling, die simpelste Form der Nebenläufigkeit.\nDesweiteren ist das XPCC Protokoll als Event-Loop implementiert und ruft die Empfänger mittels diesen\nMechanismen auf [4].</p>\n\n<p>Diese Architektur ist sehr speichereffizient und funktioniert somit auch noch auf sehr speicherlimitierten\nMikrocontrollern wie die AVRs. Für unsere Zwecke ist sie aber zu effizient, sodass es mühsam und teilweise \nunintuitiv ist, komplexere Nebenläufigkeiten abzubilden. Desweiteren nutzen wir keine AVRs mehr, sondern\nARM Cortex-M Systeme, die genügend Speicher mitbringen.</p>\n\n<p>Wir möchten mehrere Concurrency Modelle erforschen und bewerten, wie gut sie sich auf\nunser Problem anwenden lassen und wie man sie effizient auf AVR und ARM Cortex-M\nimplementiert.</p>\n\n<p>Das Resultat soll dann in modm.io implementiert werden und der Prozess ordentlich\ndokumentiert werden, sodass es auch extern genutzt werden kann.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, C11, AVR/ARMv6/v7-M Assembly</li>\n  <li>Concurrency Modelle: Actors, Threading, Coroutines, Event-Loops</li>\n  <li>AVR und ARM Cortex-M Architektur</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } 
   
  
]
