[
  
   
      {
        "title"    : "µMotor: Inbetriebnahme und Debugging",
        "category" : "",
        "tags"     : " elektronik, saison19",
        "url"      : "/blog/2018/micro-motor-debugging-inbetriebnahme.html",
        "date"     : "October 6, 2018",
        "excerpt"  : "<p>Die Idee zur Entwicklung des <a href=\"/blog/2018/micro-motor-motorcontroller.html\">µMotors</a> ist schon älter.\nDamals, als die Auswahl der Komponenten noch geschah, wurde im RCA fast zeitgleich auch der größere Bruder des µMotors, der Alpha-Motor, entworfen.</p>\n\n",
        "content"  : "<p>Die Idee zur Entwicklung des <a href=\"/blog/2018/micro-motor-motorcontroller.html\">µMotors</a> ist schon älter.\nDamals, als die Auswahl der Komponenten noch geschah, wurde im RCA fast zeitgleich auch der größere Bruder des µMotors, der Alpha-Motor, entworfen.</p>\n\n<p>Beim Design der Leistungselektronik fiel die Wahl des MOSFET-Gatetreibers auf den <a href=\"http://ww1.microchip.com/downloads/en/DeviceDoc/20005604B.pdf\">MIC4606</a> in Kombination mit den <a href=\"https://www.vishay.com/docs/68550/sqjb40ep.pdf\">SQJB40EP</a> MOSFETs von Vishay.\n(Vielen Dank an dieser Stelle an Vishay für das unkomplizierte und schnell zur Verfügung stellen von Samples.)</p>\n\n<p>Um die Eignung der ausgewählten Komponenten zu verifizieren wurde eine Testplatine entworfen, welche außerdem eine schöne und lehrreiche Aufgabe für zwei neue, bisher nicht mit dem Platinendesign vertrauten Mitgliedern des Roboterclubs darstellte.\nDie Testplatine enthielt neben den MOSFET-Treibern und MOSFETs selbst nur Stecker, Testpunkte, die nötige passive Beschaltung aus Widerständen und Kondensatoren sowie die Spannungsversorgung.</p>\n\n<p><img src=\"../../assets/img/blog/2018/alpha-motor-testboard.jpg\" alt=\"Testplatine für MIC4606\" /></p>\n\n<p>In Kombination mit einem Entwicklungs-Board für Microcontroller, in unserem Fall das [STM32F4Discovery], wurde die Ansteuerung von DC und BLDC Motoren erfolgreich getestet.</p>\n\n<p>Dadurch wurde der MIC4606 Chip für den Alpha-Motor ausgewählt und war auch für den Micro-Motor vorgesehen.\nIm Laufe der weiteren Komponentenauswahl für den Micro-Motor stellten sich die mechanischen Dimensionen des Chips allerdings als zu groß heraus und der <a href=\"http://www.ti.com/lit/ds/symlink/drv8323.pdf\">DRV8323</a> Gate-Treiber bot einen insgesamt kleineren Footprint.\nDer Chip selbst ist größer (6x6mm² WQFN zu 4x4mm² QFN), allerdings wird deutlich weniger externe Beschaltung (u.A. keine Gate-Serienwiderstände, keine Bootstrap-Kondensatoren) benötigt und drei Strommessverstärker sind direkt integriert.</p>\n\n<p>Der DRV8323 ist zugleich auch wesentlich komplexer als des MIC4606, statt einer <a href=\"https://de.wikipedia.org/wiki/Bootstrapping_(Elektrotechnik)\">Bootstrap-Schaltung</a> zur Ansteuerung der High-Side-MOSFETs integriert der Chip eine <a href=\"https://de.wikipedia.org/wiki/Ladungspumpe\">Ladungspumpe</a> und viele Parameter wie Gate-Serienwiderstände, Überstom-Abschaltung und die integrierten Strommessverstärker lassen sich beim DRV8323 digital über ein SPI-Interface konfigurieren.</p>\n\n<p>Trotzdem wurde es nicht als nötig erachtet für den DRV8323 Chip eine simple Testplatine zu entwerfen, was sich im Verlauf als Fehlentscheidung herausstellte.</p>\n\n<p>Nervig wurde die Situation bereits beim Schreiben des <a href=\"https://github.com/modm-io/modm/pull/27\">modm.io-Treibers</a>.\nEs ist meist hilfreich mit einem Logic-Analyser oder Oszilloskop de SPI-Bus auf der Platine an Testpunkten abgreifen und beobachten zu können.\nLeider passten auf die Platine des Micro-Motors keine Testpunkte, manche der Leiterbahnen waren nicht einmal auf zugänglichen Außenlagen der Platine, sondern ausschließlich unter Chips und auf den Innenlagen geführt.\nSomit musste filigraner Fädeldraht an die kleinen Lötperlen an den Außenkanten der QFN/DFN-Pads des Chips anlöten werden um an diesem Fädeldraht dann die Signale mit Logic-Analyser und Oszilloskop ab zugreifen.</p>\n\n<p><img src=\"../../assets/img/blog/2018/micro-motor-faedeldraht.jpg\" alt=\"Makro-Aufnahme Micro-Motor Fädeldraht\" /></p>\n\n<p>Dabei wurde das erste Problem recht schnell deutlich: Die MISO-Leitung des DRV8323 ist ungewöhlicherweise als <a href=\"https://de.wikipedia.org/wiki/Open-Collector-Ausgang\">Open-Drain</a> und nicht wie üblich als <a href=\"https://de.wikipedia.org/wiki/Gegentaktendstufe\">Push-Pull-Stufe</a> ausgeführt, infolgedessen wird ein externer Pull-Up-Widerstand benötigt.\nUm diesen Widerstand einzusparen sollte der intern zuschaltbare <a href=\"https://de.wikipedia.org/wiki/Pull-up-Widerstand\">Pull-Up Widerstand</a> im STM32 Microcontroller genutzt werden.\nLeider ist der Widerstand dieses Pull-Ups (laut Datenblatt 30 Kiloohm bis 70 Kiloohm viel zu groß für die minimal konfigurierbare SPI-Frequenz (mehrere 100kHz) des STM32L433 Microcontrollers.\nFolglich musste neben dem Fädeldraht für die Messinstrumente noch ein 10 Kiloohm Pull-Up-Widerstand mit Fädeldraht nachgerüstet werden.\nDas Löten war schon fast zur Routine geworden, da sich der Fädeldraht in der Zwischenzeit mehrfach gelöst hatte.</p>\n\n<p><img src=\"../../assets/img/blog/2018/micro-motor-testaufbau.jpg\" alt=\"Micro-Motor Testaufbau mit zwei Oszilloskopen und zwei Netzteilen\" /></p>\n\n<p>In Endeffekt hat die vorhandene Hardware aber ihre Inbetriebnahme und die Software-Entwicklung unter Zusatzaufwand ermöglicht.</p>\n\n<p><img src=\"../../assets/img/blog/2018/qfn-dfn-pad.jpg\" alt=\"Makro-Aufnahme: Pad eines DFN/QFN-Chips\" /></p>\n\n<p>Bis letzte Woche ein merkwürdiges Verhalten der PWM-Waveform bei der Ansteuerung von BLDC-Motoren auftrat.\nZum lokalisieren des Fehlers wurden neben den Signalen an den Motorphasen auch die Signale der Gates vor und nach dem Gatetreiber betrachtet.\nAuch diese Signale sind nur an den seitlichen Pads von QFN-Chips ab zugreifen.\nDer Pad-Pitch beträgt hier 0,5 mm, also etwa gleich dem Durchmesser des Spitze der Oszilloskop-Probe.\nNatürlich rutschte die Spitze ab und verursachte einen Kurzschluss, welcher vom Gatetreiber mit erhöhten Stromverbrauch und Rauchentwicklung quittiert wurde.</p>\n\n<p>Schnell war die Entscheidung getroffen um weitere Zerstörung zu verhindern nun doch eine Testplatine für den DRV8323-Chip zu konstruieren.</p>\n\n<p>Da es für den verwendeten Microcontroller kein Entwicklungs-Board vom Hersteller gibt wurde dieser integriert, der Schaltplan ist daher fast identisch mit dem des Micro-Motors.\nDie Platinengröße wurde von einem Kreis mit Durchmesser von 20 mm auf ein Rechteck von 100 mm x 33 mm erweitert um Platz für die etwa 50 Testpunkte zu bieten.</p>\n\n<p><img src=\"../../assets/img/blog/2018/macro-motor-pcb.png\" alt=\"Macro-Motor Testplatine\" /></p>\n\n<p>Der Name ist entsprechend auch nicht weit von Micro-Motor entfernt gewählt: <em>Macro-Motor</em>.</p>\n\n<p>Dank der schnellen Platinenfertigung von Aisler reicht eine gute Woche Wartezeit aus, bis die neue Testplatine in unserer Werkstatt liegen wird.</p>\n"
      },
   
      {
        "title"    : "Saisonstart 2019",
        "category" : "",
        "tags"     : " eurobot, saison19",
        "url"      : "/blog/2018/saisonstart-2019.html",
        "date"     : "September 18, 2018",
        "excerpt"  : "<p>Am letzten Wochenende wurden die Regeln für die kommende Eurobot-Saison erstmals veröffentlicht.\nDas Regelwerk ist noch im Beta-Status, kann aber schon auf <a href=\"http://www.eurobot.org/eurobot/eurobot-2019/eurobot-2019-rules\">eurobot.org</a> gelesen werden.</p>\n\n",
        "content"  : "<p>Am letzten Wochenende wurden die Regeln für die kommende Eurobot-Saison erstmals veröffentlicht.\nDas Regelwerk ist noch im Beta-Status, kann aber schon auf <a href=\"http://www.eurobot.org/eurobot/eurobot-2019/eurobot-2019-rules\">eurobot.org</a> gelesen werden.</p>\n\n<p><img src=\"/assets/img/blog/2018/eurobot-2019-field.png\" alt=\"\" /></p>\n\n<p>Wir freuen uns schon auf die kreative Phase in den kommenden Wochen, wenn wir die Konzepte entwickeln und Anfangen Roboter zu konstruieren.</p>\n\n<h2 id=\"mitmachen\">Mitmachen</h2>\n\n<p>Die nächste Zeit ist ideal zum Einstieg für Interessenten.\nWir haben eine Menge <a href=\"http://www.roboterclub.rwth-aachen.de/mach-mit/\">Projekte</a> für die wir motivierte Studenten suchen, egal in welchem Semester oder Studiengang.</p>\n\n<p>Wenn wir dein Interesse geweckt haben, komme Dienstag abends bei unserem <a href=\"http://www.roboterclub.rwth-aachen.de/kontakt/\">wöchentlichen Meeting</a> vorbei und lerne uns kennen.</p>\n"
      },
   
      {
        "title"    : "µMotor",
        "category" : "",
        "tags"     : " elektronik, informatik, saison19",
        "url"      : "/blog/2018/micro-motor-motorcontroller.html",
        "date"     : "May 5, 2018",
        "excerpt"  : "Die Idee ist schon älter, aber nun haben wir uns an die Umsetzung gewagt:  Ein miniaturisierter Motorcontroller, welche dezentral direkt an jeden Motor verbaut wird...",
        "content"  : "<h2 id=\"idee\">Idee</h2>\n\n<p>Die Idee ist schon älter, aber nun haben wir uns an die Umsetzung gewagt:<br />\nEin miniaturisierter Motorcontroller, welche dezentral direkt an jeden Motor verbaut wird\nund nur an Strom und CAN-Bus angeschlossen werden muss.</p>\n\n<h2 id=\"anforderungen\">Anforderungen</h2>\n\n<p>Die Anforderungen haben wir in den letzten Jahren gesammelt:</p>\n<ul>\n  <li><del>2 Phasen (nur DC Motoren) oder</del> 3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für Encoder mit AB(I)-Interface</li>\n  <li>optional Magnetencoder auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"komponentenauswahl\">Komponentenauswahl</h2>\n\n<p><img src=\"/assets/img/blog/micro-motor/umotor-pcb.jpg\" alt=\"Er ist uns beim Waschen leider etwas eingegangen. Funktioniert aber trotzdem noch.\" /></p>\n\n<p>Als nächsten Schritt mussten wir die Komponenten auswählen.\nDie Wahl des Mikrocontrollers fiel schnell und wenig überraschen auf einen STM32, konkret einen <a href=\"http://www.st.com/en/microcontrollers/stm32l433cc.html\">STM32L433CCU</a> im 7x7mm²-UFQFPN48 Gehäuse.\nGeeignete MOSFETs und MOSFET-Treiber auszuwählen gestaltete sich als deutlich komplizierter.\nEine große Herausforderung ist die kleine Baugröße von nur Ø 20mm.\nRecht schnell war klar, dass dies nur realisierbar ist mit Komponenten welche Reflow-Löten erfordern,\nsomit waren DFN-Gehäuse nicht mehr wie bei früheren Projekten im RCA unerwünscht.</p>\n\n<p>Das Anschluss ist ein 5-poliger Stecker mit CAN-Bus (2 Pins), Versorgungsspannung (12-40V), Logikspannung zu Versorgung des Controllers und natürlich Ground (GND).\nDie Logikspannung ist von der Versorgungsspannung getrennt, da letztere möglicherweise durch Not-Aus-Schaltkreise deaktiviert werden kann, wobei die Controller aktiv bleiben sollen.</p>\n\n<p>Schlussendlich haben wir nach wochenlanger Recherche den <a href=\"http://www.ti.com/product/drv8323\">DRV8323S</a> von Texas Intruments als MOSFET-Treiber ausgewählt.\nDie entscheidenden Merkmale neben dem kompakten 6x6mm²-40WQFN Gehäuse die geringe Anzahl der benötigten externen Widerstände und Kondensatoren sowie das SPI-Interface über welches alle Parameter konfiguriert werden können.\nEines der Parameter ist der Gate-Drive-Strom, dadurch können Widerstände in den Gate-Leitungen zu den MOSFETs entfallen.\nEin weiterer Vorteil ist die Ladungspumpe zur Ansteuerung der High-Side-MOSFETs welche 100% PWM-Dutycycle erlaubt in Kontrast zu Bootstrap-Schaltungen bei Alternativkomponenten.\nMit Shunt-Widerstände in zwei der drei Motor-Phasen, einem Shunt-Widerstand welche den Gesamtstrom misst und den drei integrierten Strom-Messverstärkern des Gatetreibers wird die Strommesssung und eine Cycle-by-Cycle Strombegrenzung realisiert.</p>\n\n<p>Die Wahl der MOSFETs fiel auf den Typ <a href=\"http://www.onsemi.com/PowerSolutions/product.do?id=FDMD8260L\">FDMD8260L</a>:</p>\n<ul>\n  <li>Zwei n-Channel MOSFETs im 3.3x5mm²-DFN12 Gehäuse</li>\n  <li>V_DS 60V, R_DSon 5.8 mΩ</li>\n  <li>I_D 40A (continuous max.)</li>\n</ul>\n\n<p>Aus der Rückseite befindet sich der Magnetencoder <a href=\"https://ams.com/AS5045\">AS5045B</a> von AMS,\nden wir vorher schon alleinstehend verwendet haben.\nFalls der Motor einen Encoder mitbringt kann dieser Chip nicht bestückt werden und stattdessen der Motorencoder über Lötpads unterhalb des Magnetencoder-Footprints angelötet werden.\nFür externe Motorencoder wurde zus#tzlich ein ansonsten nicht benötigter 5V-Spannungsregler vorgesehen.</p>\n\n<p>Daneben sind auf der Platine nur ein CAN-Bus-Transceiver (<a href=\"http://www.ti.com/product/tcan332\">TCAN332</a>) und Spannungsregler verbaut,\nwelche aufgrund der kleinen Bauform ausgewählt wurden.</p>\n\n<h2 id=\"schaltplan-und-layout\">Schaltplan und Layout</h2>\n\n<p><img src=\"/assets/img/blog/micro-motor/schematic-overview-screenshot.jpg\" alt=\"Schaltplanübersicht micro-motor (µMotor) in KiCad\" />\n<img src=\"/assets/img/blog/micro-motor/pcb-layout-screenshot.jpg\" alt=\"PCB Layout micro-motor (µMotor) in KiCad\" /></p>\n\n<p>Aus den Anforderungen und Überlegungen sind in den vergangenen Monaten Schaltpläne und ein kompaktes Platinenlayout entstanden.\nDas Platinenlayout ist 4-lagig ausgeführt, anders wäre die geforderte Bauform nicht umsetzbar gewesen.</p>\n\n<h2 id=\"aufbau-und-inbetriebnahme\">Aufbau und Inbetriebnahme</h2>\n\n<p>Der erste Aufbau mit Reflow-Ofen und die Inbetriebnahme gestalten sich als nicht trivial,\nweil es auf der winzigen Platine kaum möglich ist elektrische oder Software- Probleme mit Multimeter, Oszilloskop oder Logicanalyser zu debuggen.\nEinige Leitungen sind nur unter Bauteilen und auf den inneren Lagen geführt.</p>\n\n<p><img src=\"/assets/img/blog/micro-motor/pcb-assembled-before-reflow-onecent.jpg\" alt=\"micro-motor (µMotor) vor dem Reflow-Löten. Ein-Cent-Münze zum Größenvergleich.\" />\n<img src=\"/assets/img/blog/micro-motor/reflow-ofen.jpg\" alt=\"micro-motor (µMotor) im Reflow Ofen\" /></p>\n\n<p>Der erste und einzige aufgebaute Prototyp funktioniert weitgehend.\nder bisher einzige Hardwarefehler konnte mit Hilfe von Fädeldraht und einem zusätzlichen Widerstand behoben werden.</p>\n\n<h2 id=\"software\">Software</h2>\n\n<p>Die Software auf dem Mikrocontroller wird mit <a href=\"http://modm.io/\">modm</a> entwickelt.\nBisher sind die Hardware-Abstraktion (Board-Support-Package) und einige Testprogramme für die Inbetriebnahme der Hardware fertiggestellt.</p>\n\n<p>Die Hauptsoftware fehlt noch.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare Pid-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten,\nwelche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<p>Programiert werden muss der Micro-Motor über den 3D-gedruckten Programieradapter mit Federkontaktstiften.\nDer Adapter verfügt außerdem über eine Pin zum abgreifen der UART-Ausgabe zu Debug-Zwecken.</p>\n\n<p><img src=\"/assets/img/blog/micro-motor/swd-adapter.jpg\" alt=\"Programieradapter für den micro-motor (µMotor)\" /></p>\n\n<h2 id=\"ausblick\">Ausblick</h2>\n\n<p>In den nächsten Wochen werden wir die Hardware vollstandig testen, Software implementieren, Messungen vornehmen und Dokumentation schreiben.</p>\n\n<p>Zeitnah werden wir den Quellcode, Schaltplan, Platinenlayout und mechanische CAD-Modelle unter einer OpenSource Lizenz veröffentlichen.</p>\n\n<p>To be continued…</p>\n"
      },
   
      {
        "title"    : "Saisonstart 2018",
        "category" : "",
        "tags"     : " eurobot, saison18",
        "url"      : "/blog/2017/saisonstart-2018.html",
        "date"     : "October 23, 2017",
        "excerpt"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n\n",
        "content"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n\n<p><img src=\"/assets/img/blog/robo_antrieb.jpg\" alt=\"\" /></p>\n\n<p>Wir haben schonmal einen neuen Allradantrieb konstruiert, hilf uns mit ihn zu bauen.</p>\n"
      },
   
      {
        "title"    : "We are German champion 2017",
        "category" : "",
        "tags"     : " eurobot, saison17",
        "url"      : "/blog/2017/we-are-german-champion-2017.html",
        "date"     : "May 1, 2017",
        "excerpt"  : "<p>We are qualified for the international contest in France!</p>\n\n",
        "content"  : "<p>We are qualified for the international contest in France!</p>\n\n<p><img src=\"/assets/img/blog/2017/PR_Eurobot2017_Siegerfoto_Dresden.jpg\" alt=\"Eurobot 2017 Siegerfoto Dresden\" /></p>\n\n<p>Our robots, Juri and Siggi, won nearly every game at the German Eurobot contest 2018 in Dresden.\nThe competition was well organized by TURAG. Thank you for the great time!</p>\n\n<p><img src=\"/assets/img/blog/2017/Juri_Siggi_Rooftop_Back.jpg\" alt=\"Juri Siggi Rooftop Back\" /></p>\n\n<p>We would like to thank our sponsors and supporters for their generous backing.</p>\n\n<p><img src=\"/assets/img/blog/2017/Juri_Siggi_Rooftop_Front.jpg\" alt=\"Juri Siggi Rooftop Front\" /></p>\n"
      },
   
      {
        "title"    : "We are German champion 2016",
        "category" : "",
        "tags"     : " eurobot, saison17",
        "url"      : "/blog/2016/we-are-german-champion-2016.html",
        "date"     : "May 3, 2016",
        "excerpt"  : "<p>We are qualified for the international contest in France!\nOur robots, Hassel and Hoff, won every game at the German Eurobot contest 2016 in Stuttgart.</p>\n\n",
        "content"  : "<p>We are qualified for the international contest in France!\nOur robots, Hassel and Hoff, won every game at the German Eurobot contest 2016 in Stuttgart.</p>\n\n<p>The competition was well organized by VtAS. Thank you for the great time!</p>\n\n<p>We would like to thank our sponsors for their generous support.</p>\n\n<p><img src=\"/assets/img/blog/2016/Foto2016StuttgartCropped.jpg\" alt=\"RCA in Stuttgart 2016\" /></p>\n\n<p><img src=\"/assets/img/blog/2016/2016HasselHoff.jpg\" alt=\"Roboter Hassel und Hoff\" /></p>\n"
      },
   
      {
        "title"    : "The Rules for Eurobot 2016 are published",
        "category" : "",
        "tags"     : " eurobot, saison16",
        "url"      : "/blog/2015/rules-eurobot-2016.html",
        "date"     : "October 20, 2015",
        "excerpt"  : "<p>The new theme for Eurobot 2016 is “The Beach Bots”. There are many actions for the Robots to do and many parts to move. We are already brainstorming and looking forward to exiting games.</p>\n\n",
        "content"  : "<p>The new theme for Eurobot 2016 is “The Beach Bots”. There are many actions for the Robots to do and many parts to move. We are already brainstorming and looking forward to exiting games.</p>\n\n<p><img src=\"/assets/img/blog/2016/phobos_in_castle.jpg\" alt=\"Phobos in castle\" /></p>\n"
      },
   
   
   
     {
       
          "title"    : "Projekt: 3D-Drucker Octoprint",
          "category" : "Projekt",
          "tags"     : " software, 3d-druck",
          "url"      : "/projekt/3d-drucker-octoprint.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Einrichten und konfigurieren der Software Octoprint zum Betrieb des 3D-Druckers.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der 3D-Drucker soll an einen Raspberry Pi angeschlossen werden, welcher mit der Software Octoprint [1] als Server fungiert und darüber den 3D-Drucker steuern kann.</p>\n\n<p>Primär soll das Drucken von den CAD-Workstations mit wenigen Klicks zu starten sein, ebenfalls ist es wünschenswert von jedem beliebigen PC oder Laptop Druckaufträge zu erteilen und zu überwachen.</p>\n\n<p>Weitere optional umsetzbare Features sind ein Touch-Display direkt am Drucker, eine Kamera-Überwachung im Druckergehäuse sowie eine gut sichtbare LED-Statusanzeige am Drucker.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Raspberry Pi</li>\n  <li>Linux</li>\n  <li>3D-Druck</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: 3dDrive",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/3d-drive.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "3dDrive ist neues Konzept für ein Roboterfahrwerk, das in beliebige Richtung mit optimaler Beschleunigung fahren kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Differentialantrieb [1] ist der etablierte Stand der Technik im Eurobot.</p>\n\n<p>Beim Differentialantrieb werden zwei Räder auf gleicher Achse mit zwei Motoren separat angetrieben. Das Steuerprinzip ähnelt dem eines Panzers.\nNeben einfacher Steuerung und stabilem Fahrverhalten zeichnet sich der Differentialantrieb durch eine kompakte (abgeschlossene) Bauweise und die Möglichkeit, Odometrie für die Lokalisierung zu benutzen, aus.</p>\n\n<p>Da wir zur Zeit ein globales Positionierungssystem entwickeln, können auch Konzepte für neuartige Fahrwerke erprobt werden, z.B. 3dDrive. Bei dieser Antriebsart soll der Roboter drei Räder haben, die (ähnlich wie bei einem Einkaufswagen) frei verdreht werden können und angetrieben sind. Dadurch werden eine hohe Antriebsleistung und Manövrierfähigkeit erreicht.</p>\n\n<p>In Rahmen dieses Projektes soll das Konzept verfeinert und erforscht werden. Es sollen mögliche Wirkprinzipien und Implementierungen bewertet werden. Ein Prototyp soll konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Motoren (2 Lenkung, 1 Antrieb)</li>\n  <li>Beschleunigung über 1g und Geschwindigkeiten bis 2.5 m/s</li>\n  <li>Modulare Bauweise</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD Entwicklung und Konstruktion</li>\n  <li>CAM</li>\n  <li>Auslegung mechanischer, elektrischer und evtl. pneumatischer Komponenten</li>\n  <li>Entwicklung getriebetechnischer Komponenten für die Lenkung mit 2 Motoren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Aktorik für Spielelemente",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/aktorik.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Erfindung, Konstruktion und Fertigung von Greif-, Transport- und Lagersystemen für die Spielelemente der Saison 2019.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Im Eurobot-Wettbewerb müssen die Roboter regelmäßig verschiedene Objekte greifen, transportieren und nach bestimmten\nKriterien anordnen. Dazu sind kreative mechanische Lösungen notwendig, um die Aufgaben mit möglichst hoher\nGeschwindigkeit und Zuverlässigkeit innerhalb des eingeschränkten Bauraums der Roboter zu erledigen.</p>\n\n<p>Die Spielelemente waren in der Vergangenheit z.B. lackierte Holzbauklötze, Kunststoff-Zylinder, Bälle in verschiedenen\nGrößen und Materialien, Puks, CDs, Becher, Textilien, Flaschen  und ähnliches. Ähnlich zu industriellen\nAutomatisieungsaufgaben mussten diese innerhalb der 100 Sekunden eines Spiels oft an einer Stelle des Spielfeldes\neingesammelt und an einer  anderen wieder abgelegt werden und dabei z.B. nach Größe oder Farbe sortiert, geschossen\noder gestapelt werden. Dabei ist es oft erstrebenswert, möglichst viele der Elemente in den Roboter zu laden und\ngemeinsam zu transportieren. Zum Handling können z.B. aktive oder passive Greifer, Walzen, Bänder, Ketten- oder\nSchienensysteme, Gebläse, Saugnäpfe, usw. verbaut werden.</p>\n\n<p>Die Spezifikationen der Spielelemente und die damit zu lösenden Aufgaben werden mit Veröffentlichung der Regeln der\nneuen Wettbewerbssaison im September 2018 bekannt.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Erfinden von kreativen mechanischen Konzepten</li>\n  <li>„Basteln“ von Prototypen aus Holz (und Heißkleber)</li>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Aluminium- (mit CNC-Fräse) oder 3D-Druck-Teilen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Alpha-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/alpha-motor.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Alpha-Motor ist eine Platine zur Ansteuerung von zwei Antriebsmotoren und momentan die Hauptplatine des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Alpha-Motor erfüllt mehrere Funktionen gleichzeitig: Ansteuern von ein oder zwei Motoren, etwa den Antriebsmotoren des Roboters, Odometrie und das Ausführen der Robotersoftware.</p>\n\n<p>Jede Platine verfügt dazu über ein Setup, das sowohl ein oder zwei DC-Motoren als auch ein oder zwei dreiphasige Brushless-DC Motoren unterstützt.\nBenötigt werden also sechs H-Brücken aus jeweils vier Leistungstransistoren, die von drei Brückentreibern kontrolliert werden.\nDas Herzstück ist dann der Mikrocontroller.\nDieser steuert nicht nur die genannten Brückentreiber, sondern liest Motorencoder aus und kommuniziert über verschiedene Schnittstellen (vor allem CAN) mit dem Rest des Roboters.\nZusätzlich wird durch den Mikrocontroller auf zwei Wegen der Strom in den Motoren überwacht:\nEine grobe Strommessung über jeweils einen Shunt-Widerstand pro Motor und eine genauere, die von Hall-Sensoren in einem eigenen Bauteil durchgeführt wird.\nZu guter Letzt dürfen Ausgänge und LEDs zu Debug-Zwecken auch nicht fehlen.</p>\n\n<p>Auf dem Microcontroller befindet sich neben den Motor-Reglern auch der Code, der den restlichen Roboter steuert. Die Befehle werden über CAN an die Peripherie (zum Beispiel die Motortreiberplatinen “Micro-Motor” oder andere Alpha-Motor-Platinen) weitergeleitet, aber andersherum können auch Sensordaten oder die Kommunikation mit dem Display hierüber ablaufen.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Phasen (DC und Brushless-DC Motoren)</li>\n  <li>ca. 20A pro Phase in der Spitze</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Mikrocontroller STM32F407</li>\n  <li>2x CAN-Bus mit 4 Steckern, 1 UART, 1 SPI/I2C</li>\n  <li>Anschlüsse für 4 AB-Encoder inklusive UART 1-Wire</li>\n  <li>Anschlüsse für 2 Hall-Sensoren</li>\n  <li>Strommessung und Strombegrenzung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: 49 x 77 mm²</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, ADC, DAC, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardwareabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Bachelor/Master Thesis: Lokalisierung mit Ultraschall und IMU",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/imu.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Kooperative Lokalisierung mit Ultraschall und Inertial Measurement Unit (IMU) für kompetitive mobile Robotik.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Im der kommenden Saison setzt der RCA ein neues System zu Lokalisierung und der Roboter auf dem Spielfeld ein. Das Lokalisierungssystem basiert zur Zeit auf Ultraschallsignalen die von festen Ankerknoten (Baken) ausgestrahlt werden.\nDie Zeitsynchronisierung erfolgt mit Hilfe von Funksignalen.\nZusätlich können die mobilen Knoten des Systems drahtlos ihre jeweiligen Messdaten austauschen,\nso dass eine kooperative Lokalisierung ermöglicht wird. Dies ermöglicht eine Verbesserung der Zuverlässigkeit.\nDas grundlegen technische Konzept wurde in den letzten Jahren bereits entwicket und erfolgreich getestet.</p>\n\n<p>In dieser Masterarbeit sollen die mobilen Knoten des System um jeweils eine inertial measurement unit (IMU) erweitert werden.\nDabei geht es vor allem um die Implementierung und Leistungsanalyse von Sensorfusionsalgorithmen.</p>\n\n<h3 id=\"ziel\">Ziel</h3>\n\n<p>Theoretische Analyse und dazugehöriger experimenteller Aufbau eines kooperativen Lokalisierungssystems am Spielfeldrand und auf den mobilen Robotereinheiten.</p>\n\n<h3 id=\"requirements\">Requirements</h3>\n\n<ul>\n  <li>Verständnis von Signalverarbeitung</li>\n  <li>Erfahrung mit C++ Programmierung</li>\n  <li>Erfahrung mit Mikrocontrollerprogrammierung (Embedded Software Entwicklung)</li>\n  <li>Python or Matlab</li>\n</ul>\n\n<p><strong>Beneficial</strong></p>\n\n<ul>\n  <li>Soldering skills</li>\n  <li>PCB design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Battery Management System",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/batterie-management-system.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Neuentwurf des BMS (Battery Management System), das im Roboter die zentrale Komponente für Stromversorgung und Verteilung darstellt",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter werden von zwei möglich Stromquellen – einem externen Netzteil oder dem austauschbaren LiFe-Akku mit 6 Zellen – versorgt.</p>\n\n<p>Daraus müssen müssen 20–22 V Motorspannung und für die elektronischen Komponenten eine Logikspannung von ca. 7 V bereitgestellt werden. Vom Eurobot-Regelwerk wird ein Notausschalter vorgeschrieben, welcher die Motorspannung deaktiviert.</p>\n\n<p>Außerdem muss die Akkuspannung überwacht werden, um eine Tiefentladung zu verhindern, sowie alle Ausgänge gegen Kurzschlüsse abgesichert werden.\nDies alles sind Aufgaben des BMS.</p>\n\n<h3 id=\"ideen\">Ideen</h3>\n<ul>\n  <li>Dauerbelastbarkeit &gt;5A, besser &gt;10A</li>\n  <li>7V Schaltregler (TI SimpleSwitcher LMZ14xxx)</li>\n  <li>Diskussionsbedarf: Schaltregler für konstante Motorspannung?</li>\n  <li>Integrierte Akku-Spannungsüberwachung</li>\n  <li>Integrierter Microcontroller mit CAN-Interface zum Übermitteln der Akku-Zell-Spannungen</li>\n  <li>Mögliche Integration in einen Akku-Slot für passende Akku-Cases (siehe separate Projektbeschreibung)</li>\n  <li>Not-Aus Schalter nicht im Strompfad</li>\n  <li>Priorisierung des Netzteils falls Akku &amp; Netzteil angeschlossen sind</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design\n    <ul>\n      <li>Hochstrom-Design</li>\n    </ul>\n  </li>\n  <li>Akku-Spannungsüberwachung</li>\n  <li>Auslegung des Leistungselektronik</li>\n  <li>Ggf. Software für den Microcontroller (C++ mit modm.io)</li>\n  <li>Aufbau und Inbetriebnahme des Projekts</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Biegebank",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/biegebank.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Konstruktion und Fertigung einer Biegebank.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub befindet sich im Besitz einer gut ausgerüsteten Werkstatt, um mechanische Teile für die Roboter zu fertigen. Dazu gehören z.B. eine CNC-Fräse und ein 3D-Drucker.</p>\n\n<p>Jedoch müssen gebogene bzw. gekantete Bleche, die eine hervorragende Stabilität, Freiformbarkeit und ein geringes Gewicht besitzen, mit Schraubstock, Hammer, Holz und anderen improvisierten Werkzeugen gefertigt werden. Dabei sind die Biegewinkel und die Kantenlängen stark begrenzt.</p>\n\n<p>Um die Fertigung gebogener Teile zu ermöglichen, soll eine Biegebank konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Maximale Breite der Teile: 350mm</li>\n  <li>Mobil, z.B. durch eine einfache Klemmung am Tisch oder im Schraubstock</li>\n  <li>Ggf. verstellbare Blechdicke und Biegeradius</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Ggf. Rapid Prototyping mit 3D Drucker</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Ggf. werkstofftechnische Auslegung.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CAN to X",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/can-to-X.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Eine universale Platine, mit der verschiedenste Sensoren an den CAN-Bus angebunden werden können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Viele Sensoren, die wir in den verschiedenen Robotern benötigen können ohne größeren Aufwand nicht direkt an den Roboter-CAN-Bus angeschlossen werden. Die CAN-to-X-Platine soll eine Anbindung vereinfachen. Das Herz der Platine wird ein STM32F303-Microcontroller, gepaart mit einem CAN-Transceiver. Zahlreiche Steckverbinder ermöglichen den Anschluss von Sensoren und anderer Peripherie.</p>\n\n<p>Hauptsächlich muss bei diesem Projekt flexible Software für den Microcontroller geschrieben werden, um z.B. I2C- oder aber SPI-Sensoren einfach anzubinden. Auch soll die Funkkommunikation mittels NRF24L01-Chipsatz mit dieser Platine möglich sein.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>SPI</li>\n  <li>I2C</li>\n  <li>UART</li>\n  <li>CAN (Roboterclub-CAN)</li>\n  <li>Endschalter</li>\n  <li>LEDs</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Schaltplan-Entwurf</li>\n  <li>Platinendesign in KiCAD, Eagle oder Altium</li>\n  <li>SMD-Löttechnik</li>\n  <li>Software in C++, basierend auf modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CI für unsere eingebettete Software",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, werkzeug",
          "url"      : "/projekt/continous-integration.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Konzipieren und Programmieren eines CI-Service in GitLab für unsere Softwareprojekte und Anzeige auf einem Dashboard.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub hat viele eingebettete Softwareprojekte, deren Qualitäts-Zustand wir gerne im Blick behalten möchten.\nDazu brauchen wir einen sinnvollen und einfach zu benutzenden Continous Integration Service, der unsere Projekte in GitLab\nmindestens kompiliert und optional Unittests auswertet.\nEs sollen Docker Images gebaut werden um in GitLab Pipelines [1] verwendet zu werden.</p>\n\n<p>Dies ist besonders wertvoll, wenn der gesamte Setup mobil sein kann, sodass wir eine kleine Version dieses CIs zu Wettkämpfen \nmitnehmen können, bei denen es evtl. kein (oder sehr langsames) Internet gibt (*<em>hust</em>* in Frankreich *<em>hust</em>*).</p>\n\n<p>Es wäre schön, zusätzlich ein kleines Dashboard zu haben, was auf einen Blick anzeigt, wie der Zustand unserer Softwareprojekte ist.\nDieses Dashboard darf auch sehr gerne physikalisch sein (Ampel, LED Streifen oder so).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>GitLab CI Pipelines</li>\n  <li>Dashboard Programmierung</li>\n  <li>Docker Images</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CNC Fräse Aufarbeiten",
          "category" : "Projekt",
          "tags"     : " werkzeug, mechanik",
          "url"      : "/projekt/fraese-aufarbeiten.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Die CNC-Fräse wird samt Umhausung und Kühlschmiermittelkreislauf überholt.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub ist im Besitz einer CNC-Fräse vom Typ Haase Cut 2500M [1] aus dem Jahr 2008.\nHiermit fräsen wir den Großteil der Bauteile für unsere Roboter aus Aluminium, Kunststoffen oder selten auch Holz.</p>\n\n<p>Die Umhausung der Fräse weist einige Probleme auf, welche behoben werden sollen, um in Zukunft bequemes und sicheres Fräsen mit hochqualitativen Ergebnissen zu ermöglichen.</p>\n\n<p>Desweiteren gibt es viele kleine Aufgaben:</p>\n<ul>\n  <li>Die Elektrik der Fräse soll in einen bereitliegenden Schaltschrank eingebaut werden</li>\n  <li>Für die Fräse liegt eine Werkzeuglängensensor bereit, welcher eingebaut und in der Software passend konfiguriert werden muss.</li>\n  <li>Der Filter im Kühlschmiermittelkreislauf ist schwer zugänglich, daher schwer zu leeren und zu klein. Daher soll der Kühlschmiermittelkreislauf konzeptionell überarbeitet werden und neu aufgebaut werden, wobei der Kühlschmiermittel-Durchfluss erhöht wird.</li>\n  <li>Ein Spritzschutz um den Fräser herum soll konstruiert und gebaut werden.</li>\n  <li>Das Gehäuse soll von innen vollständig mit 2K-EP-Harz abgedichtet werden.</li>\n  <li>Der Endschalter der X-Achse ist defekt und muss ersetzt werden.</li>\n  <li>Verbesserung der Aufspannvorrichtung für Platten.</li>\n  <li>Beschaffung oder Konstruktion und Bau eines Schraubstocks für kleine Bauteile.</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Holz- und Metallbearbeitung</li>\n  <li>LinuxCNC</li>\n  <li>Einweisung zur Bedienung der Fräse</li>\n  <li>Schaltschrank aufbauen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Camera Recognition",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/camera-recognition.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Bildverarbeitungs Plattform für den Roboter bzw. externe Komponenten am Spielfeld.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bildverarbeitung hat im Rahmen des Eurobot vielseitige Einsatzzwecke.\nBevor/Neben der eigentlich Implementierung sollte eine möglichst standardisierte Schnittstelle für diverse zukünftige Einsatzzwecke  erstellt werden\nund wenn möglich Standard-Algorithmen vorbereitet werden.</p>\n\n<p>Am Beispiel der Spielregeln von 2018, ergeben sich zwei praktische Anwendungsfälle:</p>\n\n<ol>\n  <li>Die Erkennung eines aufgehängten Bauplanes auf dem Spielfeld (unabhängig von einem Roboter).</li>\n  <li>Zählen von Spielelementen (Klötze) in der Bauzone, zur Unterstützung/Optimierung einer Punkteschätzung.</li>\n</ol>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Recherche und Auswahl von Bildverarbeitungsalgorithmen</li>\n  <li>Definieren eines Framework</li>\n  <li>Auswahl Hardware-Plattform (Mikrocontroller bis embedPC, FPGA)</li>\n  <li>passende Auswahl Implementierungssprache</li>\n  <li>Ggf. Einbindung vorhandener Libraries</li>\n  <li>Raspberry Pi + Kamera</li>\n  <li>Kommunikation/Anbindung über XPCC</li>\n</ul>\n\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Hardware",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/debugserver-hardware.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Der Debugserver ist ein integrierter Raspberry Pi, um darüber kabellos die Roboter zu programmieren, zu debuggen, fernzusteuern und die Log-Ausgaben zu betrachten.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Ein den speziellen Anforderungen (s.u.) gerechtes Erweiterungsboard für einen RaspberryPi (“Pi HAT”) oder mit einem RaspberryPi Compute Module (CM3) [1] soll entworfen, geplant und aufgebaut werden.</p>\n\n<p>Der primäre Einsatzzweck ist der Debugserver, allerdings ist es auch denkbar, dass die Hardware für die Hauptsteuerung des Roboters genutzt wird.\nIn beiden Fällen ist absolute Zuverlässigkeit unerlässlich.</p>\n\n<p>Da die Anforderungen an mögliche Interfaces sich schnell ändern kann, wenn z.B. in Zukunft ein Laserscanner oder eine Kamera genutzt werden soll, sind viele universelle Anschlüsse am Board wünschenswert.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Raspberry Pi\n    <ul>\n      <li>Compute Module (CM3), Model 3 B+, Zero oder Zero W [2]</li>\n    </ul>\n  </li>\n  <li>WLAN 2.4GHz und 5GHz\n    <ul>\n      <li>Zwischen Client- und AccessPoint-Modus umschaltbar</li>\n    </ul>\n  </li>\n  <li>STM32-Microcontroller über SWD programmieren (z.B. per openOCD)</li>\n  <li>CAN-Interface (2x) mit MCP2515 (Linux Treiber)</li>\n  <li>UART-Interface (min. 1x; RX only) zum Empfangen der Logs vom Mikrocontroller</li>\n  <li>Echtzeituhr (RTC) für Linux-Systemzeit</li>\n  <li>Batterie-Backup\n    <ul>\n      <li>Verzögertes, kontrolliertes Herunterfahren</li>\n      <li>LiFe-Akku</li>\n      <li>Automatisches Akku-Laden über Roboter-Spannungsversorgung</li>\n    </ul>\n  </li>\n  <li>Minimales, intuitives Userinterface (LEDs, Schalter/Taster)</li>\n  <li>Kleine Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>Recherche und Auslegung LiFe-Charger</li>\n  <li>Raspberry Pi und BCM2837</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Softwarestack",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/debugserver-softwarestack.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Aufsetzten des Betriebssystems für den Raspberry Pi.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Debugserver (siehe Projekt “Debugserver Hardware”) basiert auf einem Raspberry Pi.\nAuf dem Raspberry Pi läuft ein Debian-basiertes Linux-System, dieses soll mittels <code class=\"highlighter-rouge\">debootstrap</code> [1],\nähnlich des Image-Builders [2] aufgesetzt werden um Reproduzierbarkeit zu gewährleisten.</p>\n\n<p>Zusätzlich werden diverse Dienste auf dem Debugserver benötigt, wie beipielsweise OpenOCD zum Programmieren des Mikrocontrollers, eine CAN-to-Network Brücke oder  die Überwachung des Roboterzustandes anhand welcher der Debugserver ggf. heruntergefahren wird.\nDiese Dienste müssen konfiguriert, beim Hochfahren automatisch gestartet und teilweise zuvor noch implementiert werden.\nEbenso muss die Netzwerkkonfiguaration mit der Möglichkeit zum Umschalten zwischen Client- und Accesspoint- Betrieb zuverlässig eingerichtet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Debian Stretch (9) oder Fedora\n    <ul>\n      <li>ARMv7 (<em>armhf</em>) oder ARMv8 (<em>aarch64</em>)</li>\n    </ul>\n  </li>\n  <li>Reproduzierbarkeit der Betriebssystem-Images durch Nutzung von Debootstrap und Skripten zur Installation und Konfiguration der Software</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Linux: Debian (oder Fedora?)</li>\n  <li>Systemd</li>\n  <li>Debootstrap</li>\n  <li>Systemadministration</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Webmonitor",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung",
          "url"      : "/projekt/debugserver-webmonitor.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Entwicklung einer Web-Oberfläche zur aufbereiteten Anzeige des Debug-Logs des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum einfachen Debugging unserer Roboter-Software können im Programmcode der Microcontroller Log-Nachrichten erzeugt\nwerden, die per UART (serieller Schnittstelle) ausgegeben werden. Damit diese auch bei Testspielen ohne nervige Kabel\nzum Roboter verfolgt werden können, befindet sich auf den Robotern ein RaspberryPi Pi (der „Debugserver“), der unter\nanderem mit dem UART der Hauptplatine verbunden ist. Über eine Web-Anwendung soll der Log per WLAN anderen Computern mit\nWebbrowser zugänglich gemacht werden, wobei die Nachrichten in Echtzeit angezeigt und dabei grafisch aufbereitet\nwerden sollen.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Echtzeit-Anzeige der Log-Nachrichten (per Websocket oder AJAX-Polling)</li>\n  <li>Grafische Aufbereitung der Log-Nachrichten nach bestimmten Mustern (z.B. angegebene Softwarekomponente)</li>\n  <li>Modulare und dokumentierte Software zur einfachen Wartung und Erweiterung</li>\n  <li>Ggf. Filtern des Logs nach bestimmten Mustern (z.B. Zeitpunkt, Softwarekomponente, RegEx)</li>\n  <li>Aufzeichnung des Logs in eine Datei und Abruf alter Logs aus bestehenden Dateien</li>\n  <li>Ggf. Framework zur inhaltlichen Interpretation und übersichtlichen Darstellung bestimmter Nachrichtenformate,\nz.B. Übergänge in Zustandsautomaten, Plots von aufgezeichneten Werten, …</li>\n  <li>Ggf. Überwachung des Verbindungsstatus Browser → Debugserver, Debugserver → Microcontroller</li>\n  <li>Ggf. Funktionen wie Neustart, Programmieren des Microcontroller</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Dynamische Web-Entwicklung mit einfachem Server in Python oder Ruby oder NodeJS</li>\n  <li>Entwicklung einer komplexen Singlepage-Anwendung in Javascript/ECMA-Script</li>\n  <li>Kommunikation per SocketIO-Library o.ä.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Driver",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/driver.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Entwicklung einer Softwarekomponente zur geregelten Ausführung von Fahrmanövern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Damit sich unsere Roboter kontrolliert auf dem Spielfeld bewegen können, sind Software-Routinen nötig, die verschiedene\nFahrmanöver ausführen und regeln können. Daher soll es eine Software-Komponente geben, die solche Routinen enthält und\nvon anderen Komponenten über eine definierte Schnittstelle mit Fahrmanövern beauftragt werden kann. Dabei kann es\nsich um die Rotation auf einen bestimmten Winkel, des Verfolgen einer Gerade oder eines Kreisbogens, die\ngeradlinige Anfahrt auf einen definierten Punkt, usw. handeln. Je nach Bewegungsart sind dazu unterschiedliche\ngeometrische Berechnungen, Regelungskonzepte und Sicherheitsfunktionen nötig.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Einheitliches Interface für verschiedene Fahrmanöver und Rückmeldung über Status und Fehler</li>\n  <li>Einfaches Interface zum Abfahren von Routen (Sequenzen von Fahrmanövern)</li>\n  <li>Einfache Fahrmanöver: Punkt anfahren, Gerade folgen, Kreisbogen folgen, Rotation</li>\n  <li>Komplexere Fahrmanöver: Nach Abstandssensor fahren, …</li>\n  <li>Modulare Software (DRY – Don’t Repeat Yourself), Dokumentation der Konzepte und Schnittstellen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwurf eines Software-Interfaces (in Abstimmung mit Entwicklern anderer Komponenten)</li>\n  <li>Entwicklung von Geometrieberechnungen und Positionsreglern</li>\n  <li>Softwareentwicklung in C++ mit XPCC und modm.io für Microcontroller</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Wettbewerb gewinnen",
          "category" : "Projekt",
          "tags"     : " eurobot",
          "url"      : "/projekt/win-the-eurobot.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Selbstverständlich ist das oberste Ziel natürlich den Eurobot sowohl in Deutschland, mindestens einem weiteren Land als Gast und auf dem internationalen Finale in Frankreich zu gewinnen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Einfach™ alles™ richtig™ machen™.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Platzierung: 1. Platz</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Gewinnen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Wettbewerbsspielfeld aufbauen",
          "category" : "Projekt",
          "tags"     : " eurobot, mechanik",
          "url"      : "/projekt/spielfeld.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Um unserem eigene Roboter zu testen benötigen wir das Eurobot Spielfeld.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Das Spielfeld muss gemäß der Eurobot-Regeln aufgebaut werden, die Spielelemente müssen beschafft und angepasst werden.\nÜberwiegend muss sich dabei mir der Holzbearbeitung und Lackierung beschaftigt werden.</p>\n\n<p>Das Spielfeld soll zur Wissenschaftsnacht am 9.11. fertig sein und dort ausgestellt werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Holzbearbeitung</li>\n  <li>Konstruktion</li>\n  <li>Lackieren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fahrplattform Little",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/fahrplattform-little.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Konstruktion und Fertigung der Fahrplattform des kleinen Roboters für die neue Saison (2019).",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für unsere neuen Roboter für den Eurobot-Wettbewerb 2019 müssen Grundstruktur und Antrieb konstruiert und gefertigt\nwerden. Der kleine Roboter („Little“) soll mit einem Omnidrive-Antrieb [1] ausgerüstet werden. Durch diesen kann der\nRoboter sich in alle Richtungen bewegen. Die Grundkonstruktion wird aus einer gefrästen Aluminium-Bodenplatte bestehen,\nauf der die Lagerung der drei Omniwheels, die drei Antriebsmotoren, sowie der Aufbau des Roboters montiert werden.</p>\n\n<p>Im Gegensatz zu anderen Fahrplattformen sind keine Odometrieräder zur Positionsbestimmung vorgesehen. Stattdessen sollen\nUltraschall-Baken und ggf. eine IMU [2] zur Orientierung verwendet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Geschwindigkeit 2 m/s</li>\n  <li>Kraft 50 N</li>\n  <li>Leistung 100 Watt</li>\n  <li>Motoren: 3x Maxon EC-max 30, Getriebe: 1:4,8</li>\n  <li>soll über Kanten von 3 mm fahren können</li>\n  <li>Räder Ø 50 mm</li>\n  <li>Bodenplatte Dicke ca. 10 mm\n    <ul>\n      <li>Motoren darin teilweise versenkt</li>\n    </ul>\n  </li>\n  <li>Umfang (nach Regeln 2018)\n    <ul>\n      <li>Startumfang        850 mm</li>\n      <li>Dynamischer Umfang 1050 mm</li>\n    </ul>\n  </li>\n  <li>Omnidrive (3 Räder)</li>\n  <li>IMU (inertial measurement unit) / Beschleunigungs- und Lagesensor [2]</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>3D-Druck zum Prototyping</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Simulation der Fahrdynamik (z.B. mit Matlab Simulink)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fernsteuerungs-GUI",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/python-gui.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Entwicklung einer Python/Qt-GUI-Anwendung zur Fernsteuerung und Diagnose unserer Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum Testen der Software- und Hardware-Komponenten unserer Roboter soll eine GUI-Anwendung für den Computer entwickelt\nwerden, die über Netzwerk und CAN-Bus mit der Steuerung der Roboter kommuniziert und einzelne Funktionalitäten gezielt\naufrufen kann. Ebenso soll sie verschiedene Zustände und Signale des Roboters zur Überwachung anzeigen und grafisch\naufbereiten.</p>\n\n<p>Dazu muss zunächst eine Python-Anbindung an unser Roboter-internes Kommunikations-Protokoll XPCC implementiert und die\nstrukturierte Beschreibung der Nachrichtenformate auf ein Python-Typensystem abgebildet werden. Dann können\nGUI-Anwendungen geschrieben werden: einerseits solche, die unabhängig von konkreten Problemstellungen dynamisch aus\nder strukturierten Beschreibung der Software-Komponenten erzeugt werden. Diese dienen dazu, ohne weiteren Aufwand neue\nFunktionalitäten der Robotersoftware zu testen und können auch bei anderen XPCC-basierten Projekten eingesetzt werden.</p>\n\n<p>Andererseits soll es Anwendungen mit auf bestimmte Aufgaben spezialisierten Userinterfaces geben, z.B. zur Fernsteuerung\ndes Roboterantriebs und anderer Motoren, zur Anzeige von gemessenen Sensorwerten, zum Konfigurieren der Strategie und\nStarten von Spielen, zur grafischen Anzeige der gemessenen Positionen eigener und gegnerischer Roboter auf dem\nSpielfeld, usw.</p>\n\n<h3 id=\"technische-datenfeatures\">Technische Daten/Features:</h3>\n<ul>\n  <li>Software in (pure) Python 3.x ohne Codegenerierung oder eigene native Bibliotheken</li>\n  <li>Modulare Struktur und gute Dokumentation zur einfachen Entwicklung von Fernsteueranwendungen oder anderen\nSoftware-Komponenten</li>\n  <li>Kommunikation mit den Robotern über XPCC-Protokoll via ZeroMQ</li>\n  <li>Dynamische erzeugte generische Benutzeroberfläche zur Steuerung und Diagnose beliebiger Software-Komponenten mit\nbeliebigen Parameter-/Datentypen</li>\n  <li>Komfortable Editoren für bestimmte Nachrichtenformate, z.B. Positionen auf dem Spielfeld</li>\n  <li>Framework zum einfachen Anlegen Saison-/Aufgabenspezifischer Oberflächen</li>\n  <li>Grafische Oberfläche zur Fernsteuerung der Roboterantriebe und zusätzlicher Motoren</li>\n  <li>Grafische Oberfläche zum Start des Roboters und zur Überwachung des Spielverlaufs</li>\n  <li>Grafische Oberfläche zum Debuggen und Kalibrieren der Odometrie</li>\n  <li>Grafischer Busmonitor zum Anzeigen aller oder bestimmter Bus-Nachrichten, als Rohdaten und interpretierte Werte\n(Vorbild: Wireshark)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Anwendungs-Entwicklung in Python 3.x</li>\n  <li>Entwicklung Grafischer Userinterfaces mit PyQt/Qt5</li>\n  <li>Auseinandersetzung mit den Software-Komponenten und der Kommunikation des Roboters</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Funk-Kommunikation XPCC-Backend",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/funk-komm-xpcc-backend.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Allgemeines und Standartisiertes XPCC-Backend über eine Funk-Schnittstelle.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für die grundlegende Kommunikation innerhalb der RCA-Roboter wird ein CAN-Bus verwendet.\nUm weitere Komponenten –\nwie etwa einen zweiten Roboter oder Positionierungsbaken des Gegners –\neinzubinden, muss eine Funk-Schnittstelle verwendet werden.\nEine bestehende Lösung ist bislang beschränkt auf zwei Roboter als Kommunikations-Teilnehmer, die darüber nur grundlegende Informationen für ihre Spielstrategie austauschen.</p>\n\n<p>In diesem Projekt soll das XPCC-Protokoll, das zur CAN-Kommunikation verwendet wird,\num ein allgemeines Backend für eine Funk-Schnittstelle erweitert werden.\nDamit sollen beliebige externe Komponenten (zweiter Roboter, Gegnerbaken, externe Bildverarbeitung, etc.) eingebunden werden und ohne Mehraufwand komplexe Anwendungsdaten übertragen können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation\n    <ul>\n      <li>Phy-Layer: NRF24L01</li>\n      <li>Data-Link-Layer: MAC-Layer mit R2MAC (teil von XPCC)</li>\n    </ul>\n  </li>\n  <li>Softwareentwicklung in C++ mit modm.io und XPCC für Microcontroller</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Intelligente Motor-Kommutierung",
          "category" : "Projekt",
          "tags"     : " elektronik, software",
          "url"      : "/projekt/motor-commutation.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Entwicklung einer intelligenten Kommutierungsmethode für Bürstenlose Gleichstrommotoren.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei den zumeist verwendeten Motoren handelt es sich um Bürstenlose Gleichstrommotoren (BLDC), welche von einem externen Steuergerät angesteuert werden müssen.</p>\n\n<p>Dieses Steuergerät enthält neben der Leistungselektronik auch noch Logik welche das vom Motor benötigte rotierende Magnetfeld erzeugt.</p>\n\n<p>Die einfachste und derzeit im RCA genutzte sogenannte Kommutierungsmethode ist die Block-Kommutierung.\nEs gibt Alternativen zur Block-Kommutierung, die u.a. Vorteile in den Punkten Kraft und Laufruhe bringen. Der Blog-Post [1] liefert hier ein erste Übersicht.</p>\n\n<p>Ziel diese Projektes ist die Evaluierung der Möglichkeiten sowie die Erstellung einer an die Bedürfnisse des RCA angepasste Simulation und idealerweise anschließende reale Implementation einer intelligenten Kommutierungslogik.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Software mit Echtzeit-Anforderung (Microcontroller)</li>\n  <li>STM32-Peripherie: Timer</li>\n  <li>Recherche und Dokumentation</li>\n  <li>Simulation mit geeigneter Toolchain</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Laserscanner-Positionierung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/laserscanner-positioning.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Entwicklung einer Software-Komponente zur Bestimmung der Roboterposition mit einem SICK-Laserscanner.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir besitzen einen SICK TIM 551 Laserscanner, der mittels eines Infrarotlasers radial Distanzen misst. In der richtigen\nHöhe in einen unserer Roboter eingebaut, wäre es damit prinzipiell möglich, die Roboterposition anhand der\nbeobachteten Entfernungen zum Spielfeldrand zu berechnen. Probleme machen dabei jedoch die Ausreißer durch im Lichtweg\nbefindliche Spielelemente, das Messrauschen, die zeitliche Latenz der Verarbeitung und die Verzerrung der Messungen bei\nBewegung des Roboters.</p>\n\n<p>Daher soll eine Software-Komponente entwickelt und in die Robotersoftware integriert werden, die die per Ethernet/UDP\nausgegebenen Daten des Laserscanners verarbeitet, daraus seine Position und Ausrichtung auf dem Spielfeld schätzt und\ndiese an die Robotersoftware übermittelt. Dort soll eine weitere Komponente die Positionsdaten entgegennehmen und unter\nbestimmten Voraussetzungen und Ausgleich der Zeitverzögerung die bekannte Roboterposition und -ausrichtung damit\nkorrigieren.</p>\n\n<p>Da für den Laserscanner bereits ein Treiber im Software-Framework ROS existiert, bietet es sich an, die Software zur\nPositionsberechnung ebenfalls in ROS zu entwickeln und die Daten anschließend über das XPCC-Protokoll an den\nMicrocontroller des Roboters zu senden.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Filterung der Messwerte (Tiefpass?)</li>\n  <li>Ausreißer-Elimination (z.B. RANSAC-Verfahren)</li>\n  <li>Überwachung der Roboterbewegung; Korrektur nur bei stehendem Roboter oder Entzerrung der Messung</li>\n  <li>Plausibilitätsprüfung der Positionen/Ausrichtungen vor Korrektur</li>\n  <li>Visualisierung der berechneten Daten zur Validierung des Verfahrens</li>\n  <li>Entwicklung als ROS-Node; zusätzliche Nodes zur Kommunikation mit dem Roboter</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Herleitung von Geometrische Berechnungen und Algorithmen</li>\n  <li>Entwicklung von Algorithmen zur Signalverarbeitung (Filterung, Ausreißeranalyse)</li>\n  <li>Software-Entwicklung für ROS in Python und/oder C++</li>\n  <li>Software für Microcontroller in C++ mit modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Micro-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/micro-motor.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Micro-Motor ist eine Platine zum Anschluss an CAN-Bus welche einen Motor ansteuern kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>In den Aktoren verbaute Motoren müssen angesteuert werden, dazu verfolgt der Micro-Motor das Konzept von verteilten Ansteuerungen.</p>\n\n<p>An jedem Motor wird unmittelbar eine kompakte Micro-Motor Platine montiert, welche gleichzeitig auch einen Magnet-Encoder [1] optional beinhaltet.\nDiese Platine wird über einen einzigen Stecker mit Strom und CAN-Bus versorgt und kann eigenständig den Motor ansteuern.\nZusätzlich kann ein Endschalter ausgelesen werden und die Temperatur des Motors überwacht werden.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare PID-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten, welche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für AB-Encoder</li>\n  <li>optional Magnet-Encoder [1] auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, ADC, DAC, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardwareabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/odometrie.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Implementierung von odometrischer Positionsbestimmung und einer Kalibrierungs-Routine",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs benutzen bislang Odometrie zur eigenen Lokalisierung auf dem Spielfeld. Dabei wird\nkontinuierlich aus der Drehbewegung zweier Räder die Robotergeschwindigkeit berechnet und damit die Position\nnachgeführt.</p>\n\n<p>In Rahmen dieses Projektes soll zunächst der Code für die Positionsbestimmung per Odometrie neu entworfen und\nprogrammiert werden und anschließend eine Routine zur einfachen Kalibrierung der Odometrie-Parameter entwickelt werden.\nDie neue Software-Struktur soll die Integration weiterer Positionierungsmethoden vorsehen, etwa die Ultraschall-basierte\nabsolute Positionierung (vgl. Projekt Ultraschall Lokalisierung) oder eine Inertiale Messeinheit (IMU).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Einarbeitung in die Roboterkinematik</li>\n  <li>Entwurf von Algorithmen zur Positionierung und Kalibrierung</li>\n  <li>Programmierung für eingebettete Systeme in C++ mit XPCC/modm Framework</li>\n  <li>Programmierung einer grafischen Anwendung in Python3/PyQt5</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie mit optischer Sensorik",
          "category" : "Projekt",
          "tags"     : " elektronik, software, mechanik",
          "url"      : "/projekt/odometrie-maussensoren.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Entwicklung eines optische Odometriesystems [1] für Roboterantriebe.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für den sich in Entwicklung befindenden Antrieb des kleinen Roboters – basierend auf einem Omnidrive-Antrieb (siehe separate Projektbeschreibung) – kann keine konventionelle Odometrie mit zwei zusätzlichen nicht angetriebenen Rädern zur Positionsbestimmung genutzt werden.</p>\n\n<p>Ein vielversprechendes Konzept ist die Nutzung von Sensoren aus optischen Mäusen.</p>\n\n<p>Es gab im RCA bereits Versuche mit dem – inzwischen abgekündigten und nur noch schwer erhältlichen – Sensor ADNS9800 [2] von Avago.</p>\n\n<p>Idealerweise werden im Rahmen diese Projekts ein oder mehrere geeigneter Nachfolger ausfindig gemacht, die nötige Hardware aufgebaut, Software geschrieben und die Zuverlässig unter den Bedingungen des Eurobot-Wettbewerbs erprobt.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Latenz &lt;5ms</li>\n  <li>Auflösung X und Y: &lt;1mm</li>\n  <li>Auflösung Rotation: &lt;1° (ggf. mit mehreren Sensoren)</li>\n  <li>Kleine Bauform</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Recherche verfügbare Sensoren</li>\n  <li>Software</li>\n  <li>Testbench aufbauen</li>\n  <li>ggf. PCB Design</li>\n  <li>Datenanalyse und Aufbereitung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Roboter-Caddy",
          "category" : "Projekt",
          "tags"     : " mechanik, elektronik, software",
          "url"      : "/projekt/roboter-caddy.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Um die Roboter mit Zubehör, Baken, etc. bei den Wettbewerben zum Spielfeld zu transportieren wollen wir einen coolen Roboter-Caddy bauen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei Wettbewerben sind teils längere Distanzen zwischen Team-Bereich und Spielfeld mit dem Roboter und nötigem Zubehör zu überwinden. Ein Transportfahrzeug wäre als hilfreich.\nLangweilige Implementierungen dieser Idee kann man bei anderen Teams beobachten, wo die Roboter in Bollerwägen, Kisten oder Kinderwagen transportiert werden.</p>\n\n<p>Wir wollen das natürlich weniger langweilig haben, also mit einem Antrieb und Steuerung, welche den Roboter-Caddy im besten Fall autonom einer Person folgen lässt oder Fernsteuerung ermöglicht.</p>\n\n<h3 id=\"anforderungen\">Anforderungen</h3>\n<ul>\n  <li>Kompakte Bauform, leicht zu Wettbewerben zu transportieren\n    <ul>\n      <li>in Roboterkiste integriert</li>\n      <li>zusammenklappbar</li>\n      <li>o.ä.</li>\n    </ul>\n  </li>\n  <li>Robustes Fahrwerk für unebene Böden auf Wettbewerben</li>\n  <li>Leistungsstarker Antrieb</li>\n  <li>ggf. Fernsteuerung</li>\n  <li>ggf. Autonome Navigation</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Mechanik</li>\n  <li>Elektronik</li>\n  <li>Software</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Routing-Algorithmus",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/routing.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Entwicklung und Implementierung eines Routenfindungs-Algorithmus für die Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zur Navigation unserer Roboter auf dem Spielfeld soll ein Routing-Algorithmus entwickelt werden, mit dem jeder Roboter\nautonom die optimale Route zu einem Zielpunkt auf dem Spielfeld berechnen kann. Dabei sollen Hindernisse auf dem\nSpielfeld und nach Möglichkeit die aktuellen Positionen der anderen Roboter auf dem Feld mit Bezug auf die bekannten\nAußenmaße des Roboters berücksichtigt werden. Weiterhin sollte der Algorithmus die Einschränkungen des Antriebssystems\n(Bewegungs-Freiheitsgrade, max. Beschleunigung, etc.) berücksichtigen und möglichst einfach auf andere Antriebssysteme\n(z.B. Omnidrive) erweiterbar sein.</p>\n\n<h3 id=\"featuresideen\">Features/Ideen:</h3>\n<ul>\n  <li>A*-Algorithmus auf einem kartesischen Raster auf dem Spielfeld mit ca. 30mm Auflösung, je 8 Ausrichtungen,\n8 Bewegungsrichtungen pro Feld</li>\n  <li>Dynamische Berechnung von Kantengewichten basierend auf Richtungsänderungen und Antriebssystem</li>\n  <li>Vorabberechnung gesperrter Positionen/Ausrichtungen basierend auf Hindernissen und Roboterform</li>\n  <li>Online-Berechnung zusätzlich gesperrter Positionen/Ausrichtungen basierend auf Positionen anderer Roboter</li>\n  <li>Automatische Optimierung (Postprocessing) der Route durch Kurven und Geraden in beliebigen Winkeln</li>\n  <li>Ausführung auf einem separaten Microcontroller mit externem Speicher, Anbindung per CAN-Bus</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwicklung von Routing- und Geometrieverarbeitungs-Algorithmen</li>\n  <li>Ggf. Implementierung und Validierung von Algorithmus-Prototypen in Python o.ä.</li>\n  <li>Softwareentwicklung in C++ für Microcontroller</li>\n  <li>Integration in bestehende Robotersoftware mit modm.io und XPCC</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: SCARA",
          "category" : "Projekt",
          "tags"     : " mechanik, elektronik, software",
          "url"      : "/projekt/scara.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Der SCARA ist ein Roboterarm, der sich besonders für planare Pick-And-Place-Handhabungen eignet",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der SCARA ist während der Saison 2018 enstanden und sollte zum Aufsammeln und Stapeln von Bauklötzen eingesetzt werden. Für die Handhabung ist momentan ein Saugnapf montiert.</p>\n\n<p>Angetrieben wird der Arm über insgesamt vier Motoren. Die Z-Achse wird über eine Spindel verfahren, die restlichen Motoren sind direkt mit den jeweiligen Achsen verbunden. Mit den Motorencodern werden die aktuelle Positionen erfasst, dabei ist beim Einschalten eine Referenzfahrt nötig, um die Nullpunkte der Z-Achse und Armwinkel zu ermitteln.Die gewünschte Position wird vom Anwender in kartesischen Koordinaten vorgegeben. Innerhalb der Software werden daraus die einzelnen Sollwinkel errechnet und validiert. Die Positionregelung erfolgt bislang für jeden Motor durch einen einzelnen PID-Reglern. Bei Vorgabe eines Punkts fahren alle Motoren den jeweiligen gewünschte Winkel an, wobei der langsamste Motor die Zeitdauer bestimmt. Ebenso ist der abgefahrene Weg eine Kurve, die von Anfangs- Endposition und der SCARA-Kinematik abhängt. Eine kontrollierte Fahrt entlang einer Linie ist angedacht.\nDie Mechanik ist weitgehend Spielfrei und sehr robust konstruiert. Mit geeignetem Werkzeug kann man auch Bäume ausreißen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Mechanik: CAD, Fräsen, Berechnung von Kinematik und Dynamik</li>\n  <li>Elektrik: Ansteuerung der Motoren, Auswertung der Encoder, Verkabelung</li>\n  <li>Software: Anwenderschnittstelle, Regelung und Berechnungen zur Positionierung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Sensorik zur Gewichtsmessung",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb, software, mechanik",
          "url"      : "/projekt/gewichtsmessung.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Aufbau eines Prototypen zur Gewichtsmessung von Spielelementen mit Roboterarmen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei der Ankündigung des Eurobot-Mottos für 2019 “Atom Factory” [1] wurde erwähnt, dass die Roboter Spielelemente wiegen sollen.\nAuch für einige andere Aktorik ist die Technologie hilfreich.</p>\n\n<p>Das Ziel des Projekts ist einen Prototyp einer Sensorik zur Gewichtsmessung für einen Roboterarm zu implementieren.</p>\n\n<p>Die verschiedenen möglichen Methoden zur Gewichtsmessung soll verglichen und für den Einsatz im Roboter bewertet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Mögliche Methoden\n    <ul>\n      <li>Strommessung Elektromotor</li>\n      <li>Dehnungsmessstreifen [2]</li>\n      <li>Mechanisch mit Feder und Taster</li>\n      <li>Weitere [3]</li>\n    </ul>\n  </li>\n  <li>Präzision je nach Anforderungen</li>\n  <li>Kraft/Gewicht je nach Anforderungen</li>\n  <li>Platine zum Anschluss an CAN</li>\n  <li>Kompakte Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Analoges Schaltungsdesign</li>\n  <li>PCB Design</li>\n  <li>STM32</li>\n  <li>Software Mikrocontroller</li>\n  <li>Ggf. Mechanik</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Silikon-Räder",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/silikon-raeder.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Silikon hat für die Antriebsräder sehr geeignete Eigenschaften.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs werden von Motoren angetrieben welche ihre Kraft mit Hilfe von Rädern auf den Untergrund bringen.</p>\n\n<p>Dabei spielen die Räder eine entscheidenden Faktor wie präzise und schnell der Roboter fahren, beschleunigen und bremsen kann.\nJe größer die Haftung der Räder auf dem Untergrund ist, umso besser kann Kraft übertragen werden.</p>\n\n<p>Historisch wurden im RCA modifizierte Inline-Skater-Räder oder Modellbau-Räder verwendet, in letzter Zeit hat uns die Firma TYP AG / TGW GmbH mit nach unseren Vorgaben individuell angefertigten Rädern mit vulkanisiertem Gummi unterstützt.</p>\n\n<p>Für den kleiner Roboter der Saison 2016 wurden bereits Experimente mit Silikonrädern durchgeführt, der Ergebnis war ein voller Erfolg.</p>\n\n<p>Im Rahmen dieses Projektes soll die Technologie zum Gießen von Silikon im RCA erarbeitet und dokumentiert werden und in Folge dessen für mindestens einen der Roboter Antriebs-Räder aus Silikon hergestellt werden.</p>\n\n<p>Neben den Antriebsrädern gibt es noch viele weitere Anwendungen für gegossene Silikon-Teile, beispielsweise bei Greifern.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Formen mit CNC-Fräse und/oder 3D-Drucker</li>\n  <li>Ggf. Kooperation mit einem Institut bzw. Silikonhersteller</li>\n  <li>Gießen von Silikon</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Simulator",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/simulator.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Im Simulator können die Roboter virtuell getestet werden, dazu wird die Roboterhardware emuliert und das Spielfeld mit Spielelementen sowie Gegnerroboter simuliert.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für das Testen von unserer Eurobot Spielstrategie wollen wir einen Simulator entwickeln,\nder den Roboter auf dem Spielfeld mit Spielelementen in 2 bis 2,5 Dimensionen simuliert,\nmit vereinfachten oder ideellen physikalischen Berechnungen.</p>\n\n<p>Dieser Simulator soll auch genutzt werden, um verschiedene Subsyteme des Roboters (zB. Regelungsschleifen, Sensorauswertungen mit Rauschen)\nwährend der Entwicklungsphase schnell zu testen, ohne auf einen funktionierenden Roboter angewiesen zu sein.\nInsbesondere zum Evaluieren unserer Spielstrategie ist es sinnvoll auch schneller als Echtzeit simulieren zu können.</p>\n\n<p>Desweiteren soll eine Anbindung an Matlab oder Numpy bereitstellt werden, sodass komplexere Simulationen von physikalischen \nEigenschaften als Plugin hinzugeschaltet werden können.\nDie Saison spezifischen Daten für das Spielfeld und Roboter können aus den Eurobot Shared Resources eingelesen werden [1].</p>\n\n<p>Der Zeitraum zwischen der Bekanntgabe der Eurobot-Regeln und den Wettbewerben ist mit einem halben Jahr recht kurz,\ndaher soll die Software-Entwicklung parallel zur Konstruktion und Bau der Mechanik erfolgen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Softwareentwicklung in Python oder C++ mit Qt5</li>\n  <li>Simulation von Robotern, Spielfeld und Spielelementen</li>\n  <li>Datenverarbeitung und Replay</li>\n  <li>Sensoren (Distanz, Laserscanner, Farbe, etc.)</li>\n  <li>Interface mit Matlab für Regelungen modellieren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Software auf modm portieren",
          "category" : "Projekt",
          "tags"     : " software, werkzeug",
          "url"      : "/projekt/rca-projekte-auf-modm-portieren.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Erstellung einer Skripte-Sammlung, die das Portieren unserer Software Projekte vom xpcc.io Framework zur modm.io Library (halb-)automatisch ermöglicht.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir nutzen seit 2009 das xpcc.io Framework [1] als Basis für all unsere eingebettete Software.\nVon 2016 bis 2018 haben die zwei Hauptmaintainer Fabian und Niklas H. dieses generalüberholt\nund tiefgreifende Änderungen in der Code-Generierung und teilweise der Struktur/API gemacht,\num den Code modularer und insbesondere unabhängig vom Build System zu machen.</p>\n\n<p>Der Nachfolger von xpcc heißt jetzt modm [2]. \nxpcc wird noch bis Ende 2018 maintained und danach als deprecated markiert.\nBis dahin werden alle Änderungen von xpcc nach modm von Niklas H. portiert.</p>\n\n<p>Ein oder mehrere Skripte sollen entwickelt werden, die den Hauptteil der Änderungen\nvollautomatisch, oder zumindest mit wenigen manuellen Eingriffen, anwenden.\nZusätzlich soll ein Porting Guide von xpcc auf modm für die Webseite geschrieben,\nsodass auch externe Anwender auf modm upgraden können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, Regex, Python3, SCons</li>\n  <li>Verständnis der Änderungen zwischen xpcc und modm</li>\n  <li>Code Generierung</li>\n  <li>Versionsverwaltung und CI</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Spielzeit Uhr",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/eurobot-spielzeit-uhr.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Anzeige der Spielzeit eines 100s Eurobot Spiels.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Eurobot Spiele sind 100s lang, das passt gerade noch so in zwei 7-Segment Anzeigen.\nWir haben eine große LED-Anzeige ergattert, die 6x 7-Segment Anzeigen hat (2x blau, 4x rot)\nund gut hackbar ist. Die einzelnen LED Anzeigen werden jeweils via SPI mit einem\n16-bit Constant Current LED Driver (FD9802) gesteuert.</p>\n\n<p>Wir wollen den obskuren (8-bit?) Prozessor auf dem Board ersetzen durch einen\nSTM32 (Nucleo-32 passt gut) und das Board per Funk mittels NRF24 in unsere\nRoboterfunk Verbindung einbinden, sodass das Display den Spielstart automatisch\nmitbekommt, ohne speziell konfiguriert werden zu müssen.</p>\n\n<p>Auf dem Blauen LEDs sollen die verbleibende Spielzeit angezeigt werden, und auf den\nrestlichen Anzeigen evtl. die Punkte, die unser Roboter schätzt gemacht zu haben.\nCreative Animationen mit den wenigen LEDs sind gern gesehen.</p>\n\n<h3 id=\"anforderungen\">Anforderungen</h3>\n\n<ul>\n  <li>Neue Hardware ist klein genug um im original Gehäuse zu bleiben</li>\n  <li>Leicht zu Wettbewerben mitnehmbar</li>\n  <li>Stromsparend wenn nicht in Benutzung</li>\n  <li>Automatische Erkennung von Spielstart und Punkten via Funk</li>\n  <li>Animation für Spielende</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>PCB Reverse Engineering</li>\n  <li>Funkkommunikation mit NRF24L01</li>\n  <li>Eingebettete Software mit modm.io [1]</li>\n  <li>7-Segment LED Anzeigen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Ultraschall Lokalisierung (Baken)",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/ultraschall-baken.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Unsere Roboter sollen sich mittels eines Ultraschall-Baken-Systems auf dem Spielfeld orientieren können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir wollen beim kommenden Wettbewerb ein neues System zu Lokalisierung und unserer eigenen sowie der Gegner-Roboter einsetzen.</p>\n\n<p>Das technische Konzept das Ultraschall-Lokalisierung wurde in den letzten Jahren bereits entwickelt und getestet, eine gute Übersicht liefert die Veröffentlichung [1].</p>\n\n<p>Dieses System muss nun in unsere Roboter und Gegner-Baken integriert, angepasst und getestet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Drei feste Baken am Spielfeldrand</li>\n  <li>Mobile Baken in den eigenen Robotern und in den Gegnerbaken</li>\n  <li>Geringe Latenz &lt;10ms</li>\n  <li>Genauigkeit &lt;5mm</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation mit R2MAC/NRF24L01+</li>\n  <li>Software\n    <ul>\n      <li>Portieren der Software zum modm-Framework</li>\n    </ul>\n  </li>\n  <li>ggf. PCB Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: librobots: Open Source Veröffentlichung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/librobots-open-source.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Vervollständigung und Veröffentlichung unserer internen librobots Bibliothek auf GitHub.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Es existiert recht viel Code, der jede Saison weiter benutzt wird, aber nicht \ngenerisch genug ist um in modm.io zu landen.\nDeshalb wurde angedacht, diesen Code in librobots zu überführen und dort als\neigenständiges Projekt zu warten und somit duplizierten Code zu vermeiden.\nDieses Projekt soll den Kern unserer modularen Robotersoftware werden, ähnlich\nwie xpcc bzw. modm der Kern unserer eingebetteten Software ist.\nDemzufolge soll auch die entstehende Architektur dokumentiert werden.</p>\n\n<p>Dieses Projekt ist als “Ausbildung” zum Open Source Maintainer gedacht, und ist\nsomit als Langzeitprojekt konzipiert.\nDie librobot soll zunächst im internen GitLab für die Veröffentlichung vorbereitet\nwerden und dann unter der RCA GitHub Organisation [1] als Open Source Projekt \ngeführt werden.\nDie Prozesse (Issue Tracking, Code Review, CI, Dokumentation) sollen wenn möglich\nähnlich zu modm.io gehalten werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Open Source Library Maintenance</li>\n  <li>Issue Tracking and Code Review</li>\n  <li>Architecture Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Besseres Dokumentationsformat",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, werkzeug",
          "url"      : "/projekt/modm-dokumentation.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Programmieren eines Dokutools mit Doxygen und lbuild Anbindung und Automatisierung von Doku-Qualitätkontrollen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Sowohl xpcc als auch modm [1] sind relativ gut <em>im Code</em> mittels Doxygen dokumentiert.\nFür xpcc haben wir somit einfach den generierten Doxygenoutput online gestellt [2].\nDoxygen eignet sich allerdings nicht besonders gut für Konzeptdokumentation und Beispielcode.</p>\n\n<p>Mit <code class=\"highlighter-rouge\">lbuild</code> [3] ist modm in mehrere Module aufgeteilt, die jeweils nur eine überschaubare Anzahl an Klassen verwalten.\nDiese Module können separat in Markdown dokumentiert werden und erlauben detailierte Konzeptdokumentation [4].\nDie Doxygendokumentation des Codes kann als XML ausgegeben und per Python3 eingelesen werden [5], momentan, werden\nallerdings nur die wichtigsten Objektnamen angezeigt [6].</p>\n\n<p>Es soll ein Konzept erarbeitet werden, wie am Besten die Doxygendokumentation in die Moduldokumentation eingebunden werden kann,\nsodass es einfach ist komplexe Dokumentation zu schreiben und mit der Implementation zu verlinken.\nDesweiteren sollen Beispiele in der Moduldokumentation kompilierbar sein, und wenn möglich weitere Überprüfungen (zB. valide Objektnamen im Fließtext) als Teil des CIs implementiert werden.\nDamit soll die Dokumentation synchron zur Implementierung gehalten werden.\nAbschließend soll diese Dokumentation visuell ansprechendend, durchsuchbar und gut navigierbar unter docs.modm.io automatisch\ndeployed werden.</p>\n\n<p>In Zukunft soll dieses Tool auch für librobots und evtl. andere RCA Projekte verwendet werden.\nAls Vorbild für Design und Vollständigkeit gilt die Qt5 Dokumentation [7].</p>\n\n<p><em>Es ist explizit nicht erforderlich, Dokumentation für modm zu schreiben!</em>\nEs geht hier um die automatische Erstellung und Pflege der Dokumentation, nicht unbedingt den Inhalt.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Doxygen XML Auswertung für Assembly, C, C++</li>\n  <li>Python3 und Jinja2 für Datenumwandlung und Dokumentationsgeneration</li>\n  <li>Editieren Technischer Dokumentation</li>\n  <li>Automatische Compilierung von Beispielcode</li>\n  <li>Automatisches Deployment der Dokumentation</li>\n  <li>Webdevelopment und -design, evtl. mit vorhandener Doku-Engine</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Einheitensystem und Festkomma-Arithmetik",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-units-and-fixed-point.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Implementation eines Einheitensystem mit user-defined literals und in Kombination mit Festkomma-Arithmetik für das open-source C++-Microcontroller-Framework modm.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für alle physikalischen Berechnungen in unserer Robotersoftware wollen wir Einheiten nutzen können, dies sorgt für übersichtlicheren und besser selbst-dokumentierenden Code.</p>\n\n<p>Beispiel:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>using namespace modm::units;\nlength_t distance = 300_mm;\ntime_t   time     = 1500_ms;\nvelocity_t speed  = distance / time;\nfloat foo         = distance + time; // compiler error: Units are not compatible.\n</code></pre></div></div>\n\n<p>Da es auf Microcontrollern aus verschiedenen Gründen nicht erstrebenswert mit Gleitkommazahlen zu rechnen ist, bietet es sich an gleichzeitig Festkomma-Arithmetik [1] im modm [2] zu implementieren.</p>\n\n<h3 id=\"diskussion--features\">Diskussion &amp; Features</h3>\n<ul>\n  <li>Fehlerabschätzung Multiplikation und Division</li>\n  <li>Unittests</li>\n  <li>Portieren und Anpassen bestehender Klassen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Hardware Unittests",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, elektronik, werkzeug",
          "url"      : "/projekt/modm-hwut.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Automatisches Ausführen von Unit- und Integrationstests auf Arm Cortex-M Mikrocontrollern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>modm [1] enthält eine große Anzahl an Unittests [2], die auch in unserem CI automatisch auf x86 ausgeführt werden.\nDiese Unittests können auch direkt auf dem Mikrocontroller ausgeführt werden, allerdings nur manuell und mit diversen Einschränkungen [3].\nDieser Prozess soll automatisiert werden, und die Ergebnisse als Teil des modm CIs für alle öffentlichen Pull Requests auf GitHub zur Verfügung gestellt werden.\nDazu stellen wir eine große Anzahl an diversen STM32 Discovery und Nucleo Development Boards.</p>\n\n<p>Da die modm Unittests recht begrenzt sind in ihrer Funktionalität, wäre es evtl. sinnvoll ein vollständigeres Unittest Framework wie Metal.Test zu nutzen [4].\nTracing und Performance könnte zusätzlich mit der Arm Cortex-M Debughardware erfasst werden [5].</p>\n\n<p>Zusätzlich zu in sich geschlossenen Unittests sollen auch Hardware Integrationstests erforscht werden.\nDazu gibt es Überlegungen, während eines Testes die Input/Output Werte des Mikrocontrollers mit Hilfe vom SigRok [6] zu erfassen und gegen diverse Eigenschaften und Testcases zu überprüfen.\nHier sollen verschiedene komplexe Tests gefahren und ausgewertet werden können [7], evtl. mit FPGA als IO-Multiplexer und Logikanalyzer.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Testing mit Hardware-in-Loop</li>\n  <li>Anzeige als GitHub Continuous Integration Service</li>\n  <li>Debugging mit GDB auf Arm Cortex-M</li>\n  <li>Arm Cortex-M Debug-Hardware</li>\n  <li>Erstellen von Logikwaveformtests</li>\n  <li>Automatisierte Auswertung von Logikprotokollanalysen</li>\n  <li>PCB Design mit FPGAs</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Konzept und Umsetzung einer DMA Schnittstelle",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-dma.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Erstellen eines Modells flexiblen und einfachen Nutzung von DMA (Direct Memory Access) in User-Code und anderen modm-Modulen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die meisten Mikrocontroller haben eine DMA-Einheit, welche unabhängig von der CPU auf Speicher zugreifen kann und Daten kopieren kann.\nDurch die Nutzung von DMA kann beispielsweise Peripherie wie SPI mit Daten zum senden versorgt und die empfangenen Daten gespeichert werden ohne dass die CPU hierbei belastet wird,\nwovon in modm [2] bisher kein Nutzen gemacht wird.</p>\n\n<p>Einige sehr zeitkritische Anwendungen können ohne DMA gar nicht implementiert werden,\nbeispielsweise eine Ansteuerung von WS2812-LEDs mit Bitmustern aus SPI.</p>\n\n<p>Im Rahmen dieses Projekts soll ein API für Abstraktion von DMA-Einheiten entwickelt werden welches sowohl flexibel im Bezug auf mögliche DMA-Einheiten ist,\nals auch universell in modm-Modulen wie Gerätetreibern und im User-Code einsetzbar ist.\nDie Abstraktion sollte mindestens für STM32 Mikrocontroller implementiert werden,\nweitere Implementierungen könnten später erfolgen.</p>\n\n<p>Anschließend können die vorhandene Treiber für STM32-Peripherie (SPI, UART, …) für DMA erweitert oder angepasst werden.</p>\n\n<p>Aus dem Vorgängerprojekt vom modm, xpcc, existiert eine DMA-API [1], die sich allerdings als suboptimal herausgestellt hat.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17</li>\n  <li>STM32 Speicherarchitektur, sowie weitere mögliche weitere Architekturen</li>\n  <li>STM32 Peripherie: DMA, Timer, SPI, UART, …</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Nebenläufigkeits Modelle erforschen (Concurrency)",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-concurrency-modelle.html",
          "date"     : "November 10, 2018",
          "excerpt"  : "Erstellen eines Modells zur einfachen und sicheren Beschreibung von Nebenläufigkeiten (Concurrency) für eingebettete Systeme.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Um die Nebenläufigkeiten im Robotercode zu beschreiben nutzen wir Protothreads [1], Resumable Functions [2] und Activities [3].\nDiese basieren auf sog. stackless cooperative scheduling, die simpelste Form der Nebenläufigkeit.\nDesweiteren ist das XPCC Protokoll als Event-Loop implementiert und ruft die Empfänger mittels diesen\nMechanismen auf [4].</p>\n\n<p>Diese Architektur ist sehr speichereffizient und funktioniert somit auch noch auf sehr speicherlimitierten\nMikrocontrollern wie die AVRs. Für unsere Zwecke ist sie aber zu effizient, sodass es mühsam und teilweise \nunintuitiv ist, komplexere Nebenläufigkeiten abzubilden. Desweiteren nutzen wir keine AVRs mehr, sondern\nARM Cortex-M Systeme, die genügend Speicher mitbringen.</p>\n\n<p>Wir möchten mehrere Concurrency Modelle erforschen und bewerten, wie gut sie sich auf\nunser Problem anwenden lassen und wie man sie effizient auf AVR und ARM Cortex-M\nimplementiert.</p>\n\n<p>Das Resultat soll dann in modm.io [5] implementiert werden und der Prozess ordentlich\ndokumentiert werden, sodass es auch extern genutzt werden kann.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, C11, AVR/ARMv6/v7-M Assembly</li>\n  <li>Concurrency Modelle: Actors, Threading, Coroutines, Event-Loops</li>\n  <li>AVR und ARM Cortex-M Architektur</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } 
   
  
]
