[
  
   
      {
        "title"    : "µMotor",
        "category" : "",
        "tags"     : " elektronik, informatik, saison19",
        "url"      : "/blog/2018/micro-motor-motorcontroller.html",
        "date"     : "May 5, 2018",
        "excerpt"  : "Die Idee ist schon älter, aber nun haben wir uns an die Umsetzung gewagt:  Ein miniaturisierter Motorcontroller, welche dezentral direkt an jeden Motor verbaut wird...",
        "content"  : "<h2 id=\"idee\">Idee</h2>\n\n<p>Die Idee ist schon älter, aber nun haben wir uns an die Umsetzung gewagt:<br />\nEin miniaturisierter Motorcontroller, welche dezentral direkt an jeden Motor verbaut wird\nund nur an Strom und CAN-Bus angeschlossen werden muss.</p>\n\n<h2 id=\"anforderungen\">Anforderungen</h2>\n\n<p>Die Anforderungen haben wir in den letzten Jahren gesammelt:</p>\n<ul>\n  <li><del>2 Phasen (nur DC Motoren) oder</del> 3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für Encoder mit AB(I)-Interface</li>\n  <li>optional Magnetencoder auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"komponentenauswahl\">Komponentenauswahl</h2>\n\n<p><img src=\"/assets/img/blog/micro-motor/umotor-pcb.jpg\" alt=\"Er ist uns beim Waschen leider etwas eingegangen. Funktioniert aber trotzdem noch.\" /></p>\n\n<p>Als nächsten Schritt mussten wir die Komponenten auswählen.\nDie Wahl des Mikrocontrollers fiel schnell und wenig überraschen auf einen STM32, konkret einen <a href=\"http://www.st.com/en/microcontrollers/stm32l433cc.html\">STM32L433CCU</a> im 7x7mm²-UFQFPN48 Gehäuse.\nGeeignete MOSFETs und MOSFET-Treiber auszuwählen gestaltete sich als deutlich komplizierter.\nEine große Herausforderung ist die kleine Baugröße von nur Ø 20mm.\nRecht schnell war klar, dass dies nur realisierbar ist mit Komponenten welche Reflow-Löten erfordern,\nsomit waren DFN-Gehäuse nicht mehr wie bei früheren Projekten im RCA unerwünscht.</p>\n\n<p>Das Anschluss ist ein 5-poliger Stecker mit CAN-Bus (2 Pins), Versorgungsspannung (12-40V), Logikspannung zu Versorgung des Controllers und natürlich Ground (GND).\nDie Logikspannung ist von der Versorgungsspannung getrennt, da letztere möglicherweise durch Not-Aus-Schaltkreise deaktiviert werden kann, wobei die Controller aktiv bleiben sollen.</p>\n\n<p>Schlussendlich haben wir nach wochenlanger Recherche den <a href=\"http://www.ti.com/product/drv8323\">DRV8323S</a> von Texas Intruments als MOSFET-Treiber ausgewählt.\nDie entscheidenden Merkmale neben dem kompakten 6x6mm²-40WQFN Gehäuse die geringe Anzahl der benötigten externen Widerstände und Kondensatoren sowie das SPI-Interface über welches alle Parameter konfiguriert werden können.\nEines der Parameter ist der Gate-Drive-Strom, dadurch können Widerstände in den Gate-Leitungen zu den MOSFETs entfallen.\nEin weiterer Vorteil ist die Ladungspumpe zur Ansteuerung der High-Side-MOSFETs welche 100% PWM-Dutycycle erlaubt in Kontrast zu Bootstrap-Schaltungen bei Alternativkomponenten.\nMit Shunt-Widerstände in zwei der drei Motor-Phasen, einem Shunt-Widerstand welche den Gesamtstrom misst und den drei integrierten Strom-Messverstärkern des Gatetreibers wird die Strommesssung und eine Cycle-by-Cycle Strombegrenzung realisiert.</p>\n\n<p>Die Wahl der MOSFETs fiel auf den Typ <a href=\"http://www.onsemi.com/PowerSolutions/product.do?id=FDMD8260L\">FDMD8260L</a>:</p>\n<ul>\n  <li>Zwei n-Channel MOSFETs im 3.3x5mm²-DFN12 Gehäuse</li>\n  <li>V_DS 60V, R_DSon 5.8 mΩ</li>\n  <li>I_D 40A (continuous max.)</li>\n</ul>\n\n<p>Aus der Rückseite befindet sich der Magnetencoder <a href=\"https://ams.com/AS5045\">AS5045B</a> von AMS,\nden wir vorher schon alleinstehend verwendet haben.\nFalls der Motor einen Encoder mitbringt kann dieser Chip nicht bestückt werden und stattdessen der Motorencoder über Lötpads unterhalb des Magnetencoder-Footprints angelötet werden.\nFür externe Motorencoder wurde zus#tzlich ein ansonsten nicht benötigter 5V-Spannungsregler vorgesehen.</p>\n\n<p>Daneben sind auf der Platine nur ein CAN-Bus-Transceiver (<a href=\"http://www.ti.com/product/tcan332\">TCAN332</a>) und Spannungsregler verbaut,\nwelche aufgrund der kleinen Bauform ausgewählt wurden.</p>\n\n<h2 id=\"schaltplan-und-layout\">Schaltplan und Layout</h2>\n\n<p><img src=\"/assets/img/blog/micro-motor/schematic-overview-screenshot.jpg\" alt=\"Schaltplanübersicht micro-motor (µMotor) in KiCad\" />\n<img src=\"/assets/img/blog/micro-motor/pcb-layout-screenshot.jpg\" alt=\"PCB Layout micro-motor (µMotor) in KiCad\" /></p>\n\n<p>Aus den Anforderungen und Überlegungen sind in den vergangenen Monaten Schaltpläne und ein kompaktes Platinenlayout entstanden.\nDas Platinenlayout ist 4-lagig ausgeführt, anders wäre die geforderte Bauform nicht umsetzbar gewesen.</p>\n\n<h2 id=\"aufbau-und-inbetriebnahme\">Aufbau und Inbetriebnahme</h2>\n\n<p>Der erste Aufbau mit Reflow-Ofen und die Inbetriebnahme gestalten sich als nicht trivial,\nweil es auf der winzigen Platine kaum möglich ist elektrische oder Software- Probleme mit Multimeter, Oszilloskop oder Logicanalyser zu debuggen.\nEinige Leitungen sind nur unter Bauteilen und auf den inneren Lagen geführt.</p>\n\n<p><img src=\"/assets/img/blog/micro-motor/pcb-assembled-before-reflow-onecent.jpg\" alt=\"micro-motor (µMotor) vor dem Reflow-Löten. Ein-Cent-Münze zum Größenvergleich.\" />\n<img src=\"/assets/img/blog/micro-motor/reflow-ofen.jpg\" alt=\"micro-motor (µMotor) im Reflow Ofen\" /></p>\n\n<p>Der erste und einzige aufgebaute Prototyp funktioniert weitgehend.\nder bisher einzige Hardwarefehler konnte mit Hilfe von Fädeldraht und einem zusätzlichen Widerstand behoben werden.</p>\n\n<h2 id=\"software\">Software</h2>\n\n<p>Die Software auf dem Mikrocontroller wird mit <a href=\"http://modm.io/\">modm</a> entwickelt.\nBisher sind die Hardware-Abstraktion (Board-Support-Package) und einige Testprogramme für die Inbetriebnahme der Hardware fertiggestellt.</p>\n\n<p>Die Hauptsoftware fehlt noch.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare Pid-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten,\nwelche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<p>Programiert werden muss der Micro-Motor über den 3D-gedruckten Programieradapter mit Federkontaktstiften.\nDer Adapter verfügt außerdem über eine Pin zum abgreifen der UART-Ausgabe zu Debug-Zwecken.</p>\n\n<p><img src=\"/assets/img/blog/micro-motor/swd-adapter.jpg\" alt=\"Programieradapter für den micro-motor (µMotor)\" /></p>\n\n<h2 id=\"ausblick\">Ausblick</h2>\n\n<p>In den nächsten Wochen werden wir die Hardware vollstandig testen, Software implementieren, Messungen vornehmen und Dokumentation schreiben.</p>\n\n<p>Zeitnah werden wir den Quellcode, Schaltplan, Platinenlayout und mechanische CAD-Modelle unter einer OpenSource Lizenz veröffentlichen.</p>\n\n<p>To be continued…</p>\n"
      },
   
      {
        "title"    : "Saisonstart 2018",
        "category" : "",
        "tags"     : " eurobot, saison18",
        "url"      : "/blog/2017/saisonstart-2018.html",
        "date"     : "October 23, 2017",
        "excerpt"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n\n",
        "content"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n\n<p><img src=\"/assets/img/blog/robo_antrieb.jpg\" alt=\"\" /></p>\n\n<p>Wir haben schonmal einen neuen Allradantrieb konstruiert, hilf uns mit ihn zu bauen.</p>\n"
      },
   
      {
        "title"    : "We are German champion 2017",
        "category" : "",
        "tags"     : " eurobot, saison17",
        "url"      : "/blog/2017/we-are-german-champion-2017.html",
        "date"     : "May 1, 2017",
        "excerpt"  : "<p>We are qualified for the international contest in France!</p>\n\n",
        "content"  : "<p>We are qualified for the international contest in France!</p>\n\n<p><img src=\"/assets/img/blog/2017/PR_Eurobot2017_Siegerfoto_Dresden.jpg\" alt=\"Eurobot 2017 Siegerfoto Dresden\" /></p>\n\n<p>Our robots, Juri and Siggi, won nearly every game at the German Eurobot contest 2018 in Dresden.\nThe competition was well organized by TURAG. Thank you for the great time!</p>\n\n<p><img src=\"/assets/img/blog/2017/Juri_Siggi_Rooftop_Back.jpg\" alt=\"Juri Siggi Rooftop Back\" /></p>\n\n<p>We would like to thank our sponsors and supporters for their generous backing.</p>\n\n<p><img src=\"/assets/img/blog/2017/Juri_Siggi_Rooftop_Front.jpg\" alt=\"Juri Siggi Rooftop Front\" /></p>\n"
      },
   
      {
        "title"    : "We are German champion 2016",
        "category" : "",
        "tags"     : " eurobot, saison17",
        "url"      : "/blog/2016/we-are-german-champion-2016.html",
        "date"     : "May 3, 2016",
        "excerpt"  : "<p>We are qualified for the international contest in France!\nOur robots, Hassel and Hoff, won every game at the German Eurobot contest 2016 in Stuttgart.</p>\n\n",
        "content"  : "<p>We are qualified for the international contest in France!\nOur robots, Hassel and Hoff, won every game at the German Eurobot contest 2016 in Stuttgart.</p>\n\n<p>The competition was well organized by VtAS. Thank you for the great time!</p>\n\n<p>We would like to thank our sponsors for their generous support.</p>\n\n<p><img src=\"/assets/img/blog/2016/Foto2016StuttgartCropped.jpg\" alt=\"RCA in Stuttgart 2016\" /></p>\n\n<p><img src=\"/assets/img/blog/2016/2016HasselHoff.jpg\" alt=\"Roboter Hassel und Hoff\" /></p>\n"
      },
   
      {
        "title"    : "The Rules for Eurobot 2016 are published",
        "category" : "",
        "tags"     : " eurobot, saison16",
        "url"      : "/blog/2015/rules-eurobot-2016.html",
        "date"     : "October 20, 2015",
        "excerpt"  : "<p>The new theme for Eurobot 2016 is “The Beach Bots”. There are many actions for the Robots to do and many parts to move. We are already brainstorming and looking forward to exiting games.</p>\n\n",
        "content"  : "<p>The new theme for Eurobot 2016 is “The Beach Bots”. There are many actions for the Robots to do and many parts to move. We are already brainstorming and looking forward to exiting games.</p>\n\n<p><img src=\"/assets/img/blog/2016/phobos_in_castle.jpg\" alt=\"Phobos in castle\" /></p>\n"
      },
   
   
   
     {
       
          "title"    : "Projekt: 3D-Drucker Octoprint",
          "category" : "Projekt",
          "tags"     : " software, 3d-druck",
          "url"      : "/projekt/3d-drucker-octoprint.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Einrichten und konfigurieren der Software Octoprint zum Betrieb des 3D-Druckers.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der 3D-Drucker soll an einen Raspberry Pi angeschlossen werden, welcher mit der Software Octoprint [1] als Server fungiert und darüber den 3D-Drucker steuern kann.</p>\n\n<p>Primär soll das Drucken von den CAD-Workstations mit wenigen Klicks zu starten sein, ebenfalls ist es wünschenswert von jedem beliebigen PC oder Laptop Druckaufträge zu erteilen und zu überwachen.</p>\n\n<p>Weitere optional umsetzbare Features sind ein Touch-Display direkt am Drucker, eine Kamera-Überwachung im Druckergehäuse sowie eine gut sichtbare LED-Statusanzeige am Drucker.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Raspberry Pi</li>\n  <li>Linux</li>\n  <li>3D-Druck</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: 3dDrive",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/3d-drive.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "3dDrive ist neues Konzept für ein Roboterfahrwerk, das in beliebige Richtung mit optimaler Beschleunigung fahren kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Differentialantrieb [1] ist der etablierte Stand der Technik im Eurobot.</p>\n\n<p>Beim Differentialantrieb werden zwei Räder auf gleicher Achse mit zwei Motoren separat angetrieben. Das Steuerprinzip ähnelt dem eines Panzers.\nNeben einfacher Steuerung und stabilem Fahrverhalten zeichnet sich der Differentialantrieb durch eine kompakte (abgeschlossene) Bauweise und die Möglichkeit, Odometrie für die Lokalisierung zu benutzen, aus.</p>\n\n<p>Da wir zur Zeit ein globales Positionierungssystem entwickeln, können auch Konzepte für neuartige Fahrwerke erprobt werden, z.B. 3dDrive. Bei dieser Antriebsart soll der Roboter drei Räder haben, die (ähnlich wie bei einem Einkaufswagen) frei verdreht werden können und angetrieben sind. Dadurch werden eine hohe Antriebsleistung und Manövrierfähigkeit erreicht.</p>\n\n<p>In Rahmen dieses Projektes soll das Konzept verfeinert und erforscht werden. Es sollen mögliche Wirkprinzipien und Implementierungen bewertet werden. Ein Prototyp soll konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Motoren (2 Lenkung, 1 Antrieb)</li>\n  <li>Beschleunigung über 1g und Geschwindigkeiten bis 2.5 m/s</li>\n  <li>Modulare Bauweise</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD Entwicklung und Konstruktion</li>\n  <li>CAM</li>\n  <li>Auslegung mechanischer, elektrischer und evtl. pneumatischer Komponenten</li>\n  <li>Entwicklung getriebetechnischer Komponenten für die Lenkung mit 2 Motoren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Aktorik für Spielelemente",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/aktorik.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Erfindung, Konstruktion und Fertigung von Greif-, Transport- und Lagersystemen für die Spielelemente der Saison 2019.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Im Eurobot-Wettbewerb müssen die Roboter regelmäßig verschiedene Objekte greifen, transportieren und nach bestimmten\nKriterien anordnen. Dazu sind kreative mechanische Lösungen notwendig, um die Aufgaben mit möglichst hoher\nGeschwindigkeit und Zuverlässigkeit innerhalb des eingeschränkten Bauraums der Roboter zu erledigen.</p>\n\n<p>Die Spielelemente waren in der Vergangenheit z.B. lackierte Holzbauklötze, Kunststoff-Zylinder, Bälle in verschiedenen\nGrößen und Materialien, Puks, CDs, Becher, Textilien, Flaschen  und ähnliches. Ähnlich zu industriellen\nAutomatisieungsaufgaben mussten diese innerhalb der 100 Sekunden eines Spiels oft an einer Stelle des Spielfeldes\neingesammelt und an einer  anderen wieder abgelegt werden und dabei z.B. nach Größe oder Farbe sortiert, geschossen\noder gestapelt werden. Dabei ist es oft erstrebenswert, möglichst viele der Elemente in den Roboter zu laden und\ngemeinsam zu transportieren. Zum Handling können z.B. aktive oder passive Greifer, Walzen, Bänder, Ketten- oder\nSchienensysteme, Gebläse, Saugnäpfe, usw. verbaut werden.</p>\n\n<p>Die Spezifikationen der Spielelemente und die damit zu lösenden Aufgaben werden mit Veröffentlichung der Regeln der\nneuen Wettbewerbssaison im September 2018 bekannt.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Erfinden von kreativen mechanischen Konzepten</li>\n  <li>„Basteln“ von Prototypen aus Holz (und Heißkleber)</li>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Aluminium- (mit CNC-Fräse) oder 3D-Druck-Teilen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Alpha-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/alpha-motor.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Alpha-Motor ist eine Platine zur Ansteuerung von zwei Antriebsmotoren und momentan die Hauptplatine des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Alpha-Motor erfüllt mehrere Funktionen gleichzeitig: Ansteuern von ein oder zwei Motoren, etwa den Antriebsmotoren des Roboters, Odometrie und das Ausführen der Robotersoftware.</p>\n\n<p>Jede Platine verfügt dazu über ein Setup, das sowohl ein oder zwei DC-Motoren als auch ein oder zwei dreiphasige Brushless-DC Motoren unterstützt.\nBenötigt werden also sechs H-Brücken aus jeweils vier Leistungstransistoren, die von drei Brückentreibern kontrolliert werden.\nDas Herzstück ist dann der Mikrocontroller.\nDieser steuert nicht nur die genannten Brückentreiber, sondern liest Motorencoder aus und kommuniziert über verschiedene Schnittstellen (vor allem CAN) mit dem Rest des Roboters.\nZusätzlich wird durch den Mikrocontroller auf zwei Wegen der Strom in den Motoren überwacht:\nEine grobe Strommessung über jeweils einen Shunt-Widerstand pro Motor und eine genauere, die von Hall-Sensoren in einem eigenen Bauteil durchgeführt wird.\nZu guter Letzt dürfen Ausgänge und LEDs zu Debug-Zwecken auch nicht fehlen.</p>\n\n<p>Auf dem Microcontroller befindet sich neben den Motor-Reglern auch der Code, der den restlichen Roboter steuert. Die Befehle werden über CAN an die Peripherie (zum Beispiel die Motortreiberplatinen “Micro-Motor” oder andere Alpha-Motor-Platinen) weitergeleitet, aber andersherum können auch Sensordaten oder die Kommunikation mit dem Display hierüber ablaufen.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Phasen (DC und Brushless-DC Motoren)</li>\n  <li>ca. 20A pro Phase in der Spitze</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Mikrocontroller STM32F407</li>\n  <li>2x CAN-Bus mit 4 Steckern, 1 UART, 1 SPI/I2C</li>\n  <li>Anschlüsse für 4 AB-Encoder inklusive UART 1-Wire</li>\n  <li>Anschlüsse für 2 Hall-Sensoren</li>\n  <li>Strommessung und Strombegrenzung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: 49 x 77 mm²</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, ADC, DAC, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardwareabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Battery Management System",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/batterie-management-system.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Neuentwurf des BMS (Battery Management System), das im Roboter die zentrale Komponente für Stromversorgung und Verteilung darstellt",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter werden von zwei möglich Stromquellen – einem externen Netzteil oder dem austauschbaren LiFe-Akku mit 6 Zellen – versorgt.</p>\n\n<p>Daraus müssen müssen 20–22 V Motorspannung und für die elektronischen Komponenten eine Logikspannung von ca. 7 V bereitgestellt werden. Vom Eurobot-Regelwerk wird ein Notausschalter vorgeschrieben, welcher die Motorspannung deaktiviert.</p>\n\n<p>Außerdem muss die Akkuspannung überwacht werden, um eine Tiefentladung zu verhindern, sowie alle Ausgänge gegen Kurzschlüsse abgesichert werden.\nDies alles sind Aufgaben des BMS.</p>\n\n<h3 id=\"ideen\">Ideen</h3>\n<ul>\n  <li>Dauerbelastbarkeit &gt;5A, besser &gt;10A</li>\n  <li>7V Schaltregler (TI SimpleSwitcher LMZ14xxx)</li>\n  <li>Diskussionsbedarf: Schaltregler für konstante Motorspannung?</li>\n  <li>Integrierte Akku-Spannungsüberwachung</li>\n  <li>Integrierter Microcontroller mit CAN-Interface zum Übermitteln der Akku-Zell-Spannungen</li>\n  <li>Mögliche Integration in einen Akku-Slot für passende Akku-Cases (siehe separate Projektbeschreibung)</li>\n  <li>Not-Aus Schalter nicht im Strompfad</li>\n  <li>Priorisierung des Netzteils falls Akku &amp; Netzteil angeschlossen sind</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design\n    <ul>\n      <li>Hochstrom-Design</li>\n    </ul>\n  </li>\n  <li>Akku-Spannungsüberwachung</li>\n  <li>Auslegung des Leistungselektronik</li>\n  <li>Ggf. Software für den Microcontroller (C++ mit modm.io)</li>\n  <li>Aufbau und Inbetriebnahme des Projekts</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Biegebank",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/biegebank.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Konstruktion und Fertigung einer Biegebank.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub befindet sich im Besitz einer gut ausgerüsteten Werkstatt, um mechanische Teile für die Roboter zu fertigen. Dazu gehören z.B. eine CNC-Fräse und ein 3D-Drucker.</p>\n\n<p>Jedoch müssen gebogene bzw. gekantete Bleche, die eine hervorragende Stabilität, Freiformbarkeit und ein geringes Gewicht besitzen, mit Schraubstock, Hammer, Holz und anderen improvisierten Werkzeugen gefertigt werden. Dabei sind die Biegewinkel und die Kantenlängen stark begrenzt.</p>\n\n<p>Um die Fertigung gebogener Teile zu ermöglichen, soll eine Biegebank konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Maximale Breite der Teile: 350mm</li>\n  <li>Mobil, z.B. durch eine einfache Klemmung am Tisch oder im Schraubstock</li>\n  <li>Ggf. verstellbare Blechdicke und Biegeradius</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Ggf. Rapid Prototyping mit 3D Drucker</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Ggf. werkstofftechnische Auslegung.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CAN to X",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/can-to-X.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Eine universale Platine, mit der verschiedenste Sensoren an den CAN-Bus angebunden werden können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Viele Sensoren, die wir in den verschiedenen Robotern benötigen können ohne größeren Aufwand nicht direkt an den Roboter-CAN-Bus angeschlossen werden. Die CAN-to-X-Platine soll eine Anbindung vereinfachen. Das Herz der Platine wird ein STM32F303-Microcontroller, gepaart mit einem CAN-Transceiver. Zahlreiche Steckverbinder ermöglichen den Anschluss von Sensoren und anderer Peripherie.</p>\n\n<p>Hauptsächlich muss bei diesem Projekt flexible Software für den Microcontroller geschrieben werden, um z.B. I2C- oder aber SPI-Sensoren einfach anzubinden. Auch soll die Funkkommunikation mittels NRF24L01-Chipsatz mit dieser Platine möglich sein.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>SPI</li>\n  <li>I2C</li>\n  <li>UART</li>\n  <li>CAN (Roboterclub-CAN)</li>\n  <li>Endschalter</li>\n  <li>LEDs</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Schaltplan-Entwurf</li>\n  <li>Platinendesign in KiCAD, Eagle oder Altium</li>\n  <li>SMD-Löttechnik</li>\n  <li>Software in C++, basierend auf modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CNC Fräse Aufarbeiten",
          "category" : "Projekt",
          "tags"     : " werkzeug, mechanik",
          "url"      : "/projekt/fraese-aufarbeiten.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Die CNC-Fräse wird samt Umhausung und Kühlschmiermittelkreislauf überholt.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub ist im Besitz einer CNC-Fräse vom Typ Haase Cut 2500M [1] aus dem Jahr 2008.\nHiermit fräsen wir den Großteil der Bauteile für unsere Roboter aus Aluminium, Kunststoffen oder selten auch Holz.</p>\n\n<p>Die Umhausung der Fräse weist einige Probleme auf, welche behoben werden sollen, um in Zukunft bequemes und sicheres Fräsen mit hochqualitativen Ergebnissen zu ermöglichen.</p>\n\n<p>Desweiteren gibt es viele kleine Aufgaben:</p>\n<ul>\n  <li>Die Elektrik der Fräse soll in einen bereitliegenden Schaltschrank eingebaut werden</li>\n  <li>Für die Fräse liegt eine Werkzeuglängensensor bereit, welcher eingebaut und in der Software passend konfiguriert werden muss.</li>\n  <li>Der Filter im Kühlschmiermittelkreislauf ist schwer zugänglich, daher schwer zu leeren und zu klein. Daher soll der Kühlschmiermittelkreislauf konzeptionell überarbeitet werden und neu aufgebaut werden, wobei der Kühlschmiermittel-Durchfluss erhöht wird.</li>\n  <li>Ein Spritzschutz um den Fräser herum soll konstruiert und gebaut werden.</li>\n  <li>Das Gehäuse soll von innen vollständig mit 2K-EP-Harz abgedichtet werden.</li>\n  <li>Der Endschalter der X-Achse ist defekt und muss ersetzt werden.</li>\n  <li>Verbesserung der Aufspannvorrichtung für Platten.</li>\n  <li>Beschaffung oder Konstruktion und Bau eines Schraubstocks für kleine Bauteile.</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Holz- und Metallbearbeitung</li>\n  <li>LinuxCNC</li>\n  <li>Einweisung zur Bedienung der Fräse</li>\n  <li>Schaltschrank aufbauen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Camera Recognition",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/camera-recognition.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Bildverarbeitungs Plattform für den Roboter bzw. externe Komponenten am Spielfeld.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bildverarbeitung hat im Rahmen des Eurobot vielseitige Einsatzzwecke.\nBevor/Neben der eigentlich Implementierung sollte eine möglichst standardisierte Schnittstelle für diverse zukünftige Einsatzzwecke  erstellt werden\nund wenn möglich Standard-Algorithmen vorbereitet werden.</p>\n\n<p>Am Beispiel der Spielregeln von 2018, ergeben sich zwei praktische Anwendungsfälle:</p>\n\n<ol>\n  <li>Die Erkennung eines aufgehängten Bauplanes auf dem Spielfeld (unabhängig von einem Roboter).</li>\n  <li>Zählen von Spielelementen (Klötze) in der Bauzone, zur Unterstützung/Optimierung einer Punkteschätzung.</li>\n</ol>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Recherche und Auswahl von Bildverarbeitungsalgorithmen</li>\n  <li>Definieren eines Framework</li>\n  <li>Auswahl Hardware-Plattform (Mikrocontroller bis embedPC, FPGA)</li>\n  <li>passende Auswahl Implementierungssprache</li>\n  <li>Ggf. Einbindung vorhandener Libraries</li>\n  <li>Raspberry Pi + Kamera</li>\n  <li>Kommunikation/Anbindung über XPCC</li>\n</ul>\n\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver Hardware",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/debugserver-hardware.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Der Debugserver ist ein integrierter Raspberry Pi, um darüber kabellos die Roboter zu programmieren, zu debuggen, fernzusteuern und die Log-Ausgaben zu betrachten.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Ein den speziellen Anforderungen (s.u.) gerechtes Erweiterungsboard für einen RaspberryPi (“Pi HAT”) oder mit einem RaspberryPi Compute Module (CM3) [1] soll entworfen, geplant und aufgebaut werden.</p>\n\n<p>Der primäre Einsatzzweck ist der Debugserver, allerdings ist es auch denkbar, dass die Hardware für die Hauptsteuerung des Roboters genutzt wird.\nIn beiden Fällen ist absolute Zuverlässigkeit unerlässlich.</p>\n\n<p>Da die Anforderungen an mögliche Interfaces sich schnell ändern kann, wenn z.B. in Zukunft ein Laserscanner oder eine Kamera genutzt werden soll, sind viele universelle Anschlüsse am Board wünschenswert.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Raspberry Pi\n    <ul>\n      <li>Compute Module (CM3), Model 3 B+, Zero oder Zero W [2]</li>\n    </ul>\n  </li>\n  <li>WLAN 2.4GHz und 5GHz\n    <ul>\n      <li>Zwischen Client- und AccessPoint-Modus umschaltbar</li>\n    </ul>\n  </li>\n  <li>STM32-Microcontroller über SWD programmieren (z.B. per openOCD)</li>\n  <li>CAN-Interface (2x) mit MCP2515 (Linux Treiber)</li>\n  <li>UART-Interface (min. 1x; RX only) zum Empfangen der Logs vom Mikrocontroller</li>\n  <li>Echtzeituhr (RTC) für Linux-Systemzeit</li>\n  <li>Batterie-Backup\n    <ul>\n      <li>Verzögertes, kontrolliertes Herunterfahren</li>\n      <li>LiFe-Akku</li>\n      <li>Automatisches Akku-Laden über Roboter-Spannungsversorgung</li>\n    </ul>\n  </li>\n  <li>Minimales, intuitives Userinterface (LEDs, Schalter/Taster)</li>\n  <li>Kleine Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>Recherche und Auslegung LiFe-Charger</li>\n  <li>Raspberry Pi und BCM2837</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Softwarestack",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/debugserver-softwarestack.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Aufsetzten des Betriebssystems für den Raspberry Pi.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Debugserver (siehe Projekt “Debugserver Hardware”) basiert auf einem Raspberry Pi.\nAuf dem Raspberry Pi läuft ein Debian-basiertes Linux-System, dieses soll mittels <code class=\"highlighter-rouge\">debootstrap</code> [1],\nähnlich des Image-Builders [2] aufgesetzt werden um Reproduzierbarkeit zu gewährleisten.</p>\n\n<p>Zusätzlich werden diverse Dienste auf dem Debugserver benötigt, wie beipielsweise OpenOCD zum Programmieren des Mikrocontrollers, eine CAN-to-Network Brücke oder  die Überwachung des Roboterzustandes anhand welcher der Debugserver ggf. heruntergefahren wird.\nDiese Dienste müssen konfiguriert, beim Hochfahren automatisch gestartet und teilweise zuvor noch implementiert werden.\nEbenso muss die Netzwerkkonfiguaration mit der Möglichkeit zum Umschalten zwischen Client- und Accesspoint- Betrieb zuverlässig eingerichtet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Debian Stretch (9) oder Fedora\n    <ul>\n      <li>ARMv7 (<em>armhf</em>) oder ARMv8 (<em>aarch64</em>)</li>\n    </ul>\n  </li>\n  <li>Reproduzierbarkeit der Betriebssystem-Images durch Nutzung von Debootstrap und Skripten zur Installation und Konfiguration der Software</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Linux: Debian (oder Fedora?)</li>\n  <li>Systemd</li>\n  <li>Debootstrap</li>\n  <li>Systemadministration</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Webmonitor",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung",
          "url"      : "/projekt/debugserver-webmonitor.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Entwicklung einer Web-Oberfläche zur aufbereiteten Anzeige des Debug-Logs des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum einfachen Debugging unserer Roboter-Software können im Programmcode der Microcontroller Log-Nachrichten erzeugt\nwerden, die per UART (serieller Schnittstelle) ausgegeben werden. Damit diese auch bei Testspielen ohne nervige Kabel\nzum Roboter verfolgt werden können, befindet sich auf den Robotern ein RaspberryPi Pi (der „Debugserver“), der unter\nanderem mit dem UART der Hauptplatine verbunden ist. Über eine Web-Anwendung soll der Log per WLAN anderen Computern mit\nWebbrowser zugänglich gemacht werden, wobei die Nachrichten in Echtzeit angezeigt und dabei grafisch aufbereitet\nwerden sollen.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Echtzeit-Anzeige der Log-Nachrichten (per Websocket oder AJAX-Polling)</li>\n  <li>Grafische Aufbereitung der Log-Nachrichten nach bestimmten Mustern (z.B. angegebene Softwarekomponente)</li>\n  <li>Modulare und dokumentierte Software zur einfachen Wartung und Erweiterung</li>\n  <li>Ggf. Filtern des Logs nach bestimmten Mustern (z.B. Zeitpunkt, Softwarekomponente, RegEx)</li>\n  <li>Aufzeichnung des Logs in eine Datei und Abruf alter Logs aus bestehenden Dateien</li>\n  <li>Ggf. Framework zur inhaltlichen Interpretation und übersichtlichen Darstellung bestimmter Nachrichtenformate,\nz.B. Übergänge in Zustandsautomaten, Plots von aufgezeichneten Werten, …</li>\n  <li>Ggf. Überwachung des Verbindungsstatus Browser → Debugserver, Debugserver → Microcontroller</li>\n  <li>Ggf. Funktionen wie Neustart, Programmieren des Microcontroller</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Dynamische Web-Entwicklung mit einfachem Server in Python oder Ruby oder NodeJS</li>\n  <li>Entwicklung einer komplexen Singlepage-Anwendung in Javascript/ECMA-Script</li>\n  <li>Kommunikation per SocketIO-Library o.ä.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Driver",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/driver.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Entwicklung einer Softwarekomponente zur geregelten Ausführung von Fahrmanövern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Damit sich unsere Roboter kontrolliert auf dem Spielfeld bewegen können, sind Software-Routinen nötig, die verschiedene\nFahrmanöver ausführen und regeln können. Daher soll es eine Software-Komponente geben, die solche Routinen enthält und\nvon anderen Komponenten über eine definierte Schnittstelle mit Fahrmanövern beauftragt werden kann. Dabei kann es\nsich um die Rotation auf einen bestimmten Winkel, des Verfolgen einer Gerade oder eines Kreisbogens, die\ngeradlinige Anfahrt auf einen definierten Punkt, usw. handeln. Je nach Bewegungsart sind dazu unterschiedliche\ngeometrische Berechnungen, Regelungskonzepte und Sicherheitsfunktionen nötig.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Einheitliches Interface für verschiedene Fahrmanöver und Rückmeldung über Status und Fehler</li>\n  <li>Einfaches Interface zum Abfahren von Routen (Sequenzen von Fahrmanövern)</li>\n  <li>Einfache Fahrmanöver: Punkt anfahren, Gerade folgen, Kreisbogen folgen, Rotation</li>\n  <li>Komplexere Fahrmanöver: Nach Abstandssensor fahren, …</li>\n  <li>Modulare Software (DRY – Don’t Repeat Yourself), Dokumentation der Konzepte und Schnittstellen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwurf eines Software-Interfaces (in Abstimmung mit Entwicklern anderer Komponenten)</li>\n  <li>Entwicklung von Geometrieberechnungen und Positionsreglern</li>\n  <li>Softwareentwicklung in C++ mit XPCC und modm.io für Microcontroller</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Wettbewerb gewinnen",
          "category" : "Projekt",
          "tags"     : " eurobot",
          "url"      : "/projekt/win-the-eurobot.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Selbstverständlich ist das oberste Ziel natürlich den Eurobot sowohl in Deutschland, mindestens einem weiteren Land als Gast und auf dem internationalen Finale in Frankreich zu gewinnen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Einfach™ alles™ richtig™ machen™.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Platzierung: 1. Platz</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Gewinnen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fahrplattform Little",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/fahrplattform-little.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Konstruktion und Fertigung der Fahrplattform des kleinen Roboters für die neue Saison (2019).",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für unsere neuen Roboter für den Eurobot-Wettbewerb 2019 müssen Grundstruktur und Antrieb konstruiert und gefertigt\nwerden. Der kleine Roboter („Little“) soll mit einem Omnidrive-Antrieb [1] ausgerüstet werden. Durch diesen kann der\nRoboter sich in alle Richtungen bewegen. Die Grundkonstruktion wird aus einer gefrästen Aluminium-Bodenplatte bestehen,\nauf der die Lagerung der drei Omniwheels, die drei Antriebsmotoren, sowie der Aufbau des Roboters montiert werden.</p>\n\n<p>Im Gegensatz zu anderen Fahrplattformen sind keine Odometrieräder zur Positionsbestimmung vorgesehen. Stattdessen sollen\nUltraschall-Baken und ggf. eine IMU [2] zur Orientierung verwendet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Geschwindigkeit 2 m/s</li>\n  <li>Kraft 50 N</li>\n  <li>Leistung 100 Watt</li>\n  <li>Motoren: 3x Maxon EC-max 30, Getriebe: 1:4,8</li>\n  <li>soll über Kanten von 3 mm fahren können</li>\n  <li>Räder Ø 50 mm</li>\n  <li>Bodenplatte Dicke ca. 10 mm\n    <ul>\n      <li>Motoren darin teilweise versenkt</li>\n    </ul>\n  </li>\n  <li>Umfang (nach Regeln 2018)\n    <ul>\n      <li>Startumfang        850 mm</li>\n      <li>Dynamischer Umfang 1050 mm</li>\n    </ul>\n  </li>\n  <li>Omnidrive (3 Räder)</li>\n  <li>IMU (inertial measurement unit) / Beschleunigungs- und Lagesensor [2]</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>3D-Druck zum Prototyping</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Simulation der Fahrdynamik (z.B. mit Matlab Simulink)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fernsteuerungs-GUI",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/python-gui.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Entwicklung einer Python/Qt-GUI-Anwendung zur Fernsteuerung und Diagnose unserer Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum Testen der Software- und Hardware-Komponenten unserer Roboter soll eine GUI-Anwendung für den Computer entwickelt\nwerden, die über Netzwerk und CAN-Bus mit der Steuerung der Roboter kommuniziert und einzelne Funktionalitäten gezielt\naufrufen kann. Ebenso soll sie verschiedene Zustände und Signale des Roboters zur Überwachung anzeigen und grafisch\naufbereiten.</p>\n\n<p>Dazu muss zunächst eine Python-Anbindung an unser Roboter-internes Kommunikations-Protokoll XPCC implementiert und die\nstrukturierte Beschreibung der Nachrichtenformate auf ein Python-Typensystem abgebildet werden. Dann können\nGUI-Anwendungen geschrieben werden: einerseits solche, die unabhängig von konkreten Problemstellungen dynamisch aus\nder strukturierten Beschreibung der Software-Komponenten erzeugt werden. Diese dienen dazu, ohne weiteren Aufwand neue\nFunktionalitäten der Robotersoftware zu testen und können auch bei anderen XPCC-basierten Projekten eingesetzt werden.</p>\n\n<p>Andererseits soll es Anwendungen mit auf bestimmte Aufgaben spezialisierten Userinterfaces geben, z.B. zur Fernsteuerung\ndes Roboterantriebs und anderer Motoren, zur Anzeige von gemessenen Sensorwerten, zum Konfigurieren der Strategie und\nStarten von Spielen, zur grafischen Anzeige der gemessenen Positionen eigener und gegnerischer Roboter auf dem\nSpielfeld, usw.</p>\n\n<h3 id=\"technische-datenfeatures\">Technische Daten/Features:</h3>\n<ul>\n  <li>Software in (pure) Python 3.x ohne Codegenerierung oder eigene native Bibliotheken</li>\n  <li>Modulare Struktur und gute Dokumentation zur einfachen Entwicklung von Fernsteueranwendungen oder anderen\nSoftware-Komponenten</li>\n  <li>Kommunikation mit den Robotern über XPCC-Protokoll via ZeroMQ</li>\n  <li>Dynamische erzeugte generische Benutzeroberfläche zur Steuerung und Diagnose beliebiger Software-Komponenten mit\nbeliebigen Parameter-/Datentypen</li>\n  <li>Komfortable Editoren für bestimmte Nachrichtenformate, z.B. Positionen auf dem Spielfeld</li>\n  <li>Framework zum einfachen Anlegen Saison-/Aufgabenspezifischer Oberflächen</li>\n  <li>Grafische Oberfläche zur Fernsteuerung der Roboterantriebe und zusätzlicher Motoren</li>\n  <li>Grafische Oberfläche zum Start des Roboters und zur Überwachung des Spielverlaufs</li>\n  <li>Grafische Oberfläche zum Debuggen und Kalibrieren der Odometrie</li>\n  <li>Grafischer Busmonitor zum Anzeigen aller oder bestimmter Bus-Nachrichten, als Rohdaten und interpretierte Werte\n(Vorbild: Wireshark)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Anwendungs-Entwicklung in Python 3.x</li>\n  <li>Entwicklung Grafischer Userinterfaces mit PyQt/Qt5</li>\n  <li>Auseinandersetzung mit den Software-Komponenten und der Kommunikation des Roboters</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Funk-Kommunikation XPCC-Backend",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/funk-komm-xpcc-backend.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Allgemeines und Standartisiertes XPCC-Backend über eine Funk-Schnittstelle.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für die grundlegende Kommunikation innerhalb der RCA-Roboter wird ein CAN-Bus verwendet.\nUm weitere Komponenten –\nwie etwa einen zweiten Roboter oder Positionierungsbaken des Gegners –\neinzubinden, muss eine Funk-Schnittstelle verwendet werden.\nEine bestehende Lösung ist bislang beschränkt auf zwei Roboter als Kommunikations-Teilnehmer, die darüber nur grundlegende Informationen für ihre Spielstrategie austauschen.</p>\n\n<p>In diesem Projekt soll das XPCC-Protokoll, das zur CAN-Kommunikation verwendet wird,\num ein allgemeines Backend für eine Funk-Schnittstelle erweitert werden.\nDamit sollen beliebige externe Komponenten (zweiter Roboter, Gegnerbaken, externe Bildverarbeitung, etc.) eingebunden werden und ohne Mehraufwand komplexe Anwendungsdaten übertragen können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation\n    <ul>\n      <li>Phy-Layer: NRF24L01</li>\n      <li>Data-Link-Layer: MAC-Layer mit R2MAC (teil von XPCC)</li>\n    </ul>\n  </li>\n  <li>Softwareentwicklung in C++ mit modm.io und XPCC für Microcontroller</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: IMU (auch als Abschlussarbeit)",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/imu.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "IMU für eine stabilere und effizientere Positionierung und Antriebsregelung.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Inertial Measurement Unit (Inertiale Messeinheit) [1] ist eine Kombination der Beschleunigungssensoren und Drehratensonseren.\nDiese sind meistens auf einer Platine bzw. Chip angebracht und ermöglichen eine Erfassung der Bewegung.\nDurch die Zeitliche Integration der Messwerte kann es auch auf die Geschwindigkeit und Position geschlossen werden.</p>\n\n<p>Eine IMU soll in unsere Roboter mechanisch, elektrisch und software-technisch integriert werden.\nDadurch verbessern sich die Positionierung (Ein Filter für das globale Positionierungssystem) und die Antriebsregelung (Beschleunigungsmessung für eine bessere Kontrolle in der Kurve).</p>\n\n<p>Dieses Projekt kann auch als eine Abschlussarbeit am Instituts für Theoretische Informationstechnik (Fakultät 6) [2] gemacht werden.\nDie möglichen Themen wären: Kooperative Lokalisierung, Kalmanfilter.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>Kandidat: Bosch BNO055</li>\n  <li>Je 1 IMU auf unseren und gegnerischen Roboter</li>\n  <li>Integration mit dem globalen Positionierungssystem</li>\n  <li>Echtzeitfähigkeit für die Regelung</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Software-, Regler- und Filterentwicklung in C++ und z.B. Matlab</li>\n  <li>?..</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Intelligente Motor-Kommutierung",
          "category" : "Projekt",
          "tags"     : " elektronik, software",
          "url"      : "/projekt/motor-commutation.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Entwicklung einer intelligenten Kommutierungsmethode für Bürstenlose Gleichstrommotoren.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei den zumeist verwendeten Motoren handelt es sich um Bürstenlose Gleichstrommotoren (BLDC), welche von einem externen Steuergerät angesteuert werden müssen.</p>\n\n<p>Dieses Steuergerät enthält neben der Leistungselektronik auch noch Logik welche das vom Motor benötigte rotierende Magnetfeld erzeugt.</p>\n\n<p>Die einfachste und derzeit im RCA genutzte sogenannte Kommutierungsmethode ist die Block-Kommutierung.\nEs gibt Alternativen zur Block-Kommutierung, die u.a. Vorteile in den Punkten Kraft und Laufruhe bringen. Der Blog-Post [1] liefert hier ein erste Übersicht.</p>\n\n<p>Ziel diese Projektes ist die Evaluierung der Möglichkeiten sowie die Erstellung einer an die Bedürfnisse des RCA angepasste Simulation und idealerweise anschließende reale Implementation einer intelligenten Kommutierungslogik.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Software mit Echtzeit-Anforderung (Microcontroller)</li>\n  <li>STM32-Peripherie: Timer</li>\n  <li>Recherche und Dokumentation</li>\n  <li>Simulation mit geeigneter Toolchain</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Laserscanner-Positionierung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/laserscanner-positioning.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Entwicklung einer Software-Komponente zur Bestimmung der Roboterposition mit einem SICK-Laserscanner.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir besitzen einen SICK TIM 551 Laserscanner, der mittels eines Infrarotlasers radial Distanzen misst. In der richtigen\nHöhe in einen unserer Roboter eingebaut, wäre es damit prinzipiell möglich, die Roboterposition anhand der\nbeobachteten Entfernungen zum Spielfeldrand zu berechnen. Probleme machen dabei jedoch die Ausreißer durch im Lichtweg\nbefindliche Spielelemente, das Messrauschen, die zeitliche Latenz der Verarbeitung und die Verzerrung der Messungen bei\nBewegung des Roboters.</p>\n\n<p>Daher soll eine Software-Komponente entwickelt und in die Robotersoftware integriert werden, die die per Ethernet/UDP\nausgegebenen Daten des Laserscanners verarbeitet, daraus seine Position und Ausrichtung auf dem Spielfeld schätzt und\ndiese an die Robotersoftware übermittelt. Dort soll eine weitere Komponente die Positionsdaten entgegennehmen und unter\nbestimmten Voraussetzungen und Ausgleich der Zeitverzögerung die bekannte Roboterposition und -ausrichtung damit\nkorrigieren.</p>\n\n<p>Da für den Laserscanner bereits ein Treiber im Software-Framework ROS existiert, bietet es sich an, die Software zur\nPositionsberechnung ebenfalls in ROS zu entwickeln und die Daten anschließend über das XPCC-Protokoll an den\nMicrocontroller des Roboters zu senden.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Filterung der Messwerte (Tiefpass?)</li>\n  <li>Ausreißer-Elimination (z.B. RANSAC-Verfahren)</li>\n  <li>Überwachung der Roboterbewegung; Korrektur nur bei stehendem Roboter oder Entzerrung der Messung</li>\n  <li>Plausibilitätsprüfung der Positionen/Ausrichtungen vor Korrektur</li>\n  <li>Visualisierung der berechneten Daten zur Validierung des Verfahrens</li>\n  <li>Entwicklung als ROS-Node; zusätzliche Nodes zur Kommunikation mit dem Roboter</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Herleitung von Geometrische Berechnungen und Algorithmen</li>\n  <li>Entwicklung von Algorithmen zur Signalverarbeitung (Filterung, Ausreißeranalyse)</li>\n  <li>Software-Entwicklung für ROS in Python und/oder C++</li>\n  <li>Software für Microcontroller in C++ mit modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Micro-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/micro-motor.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Micro-Motor ist eine Platine zum Anschluss an CAN-Bus welche einen Motor ansteuern kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>In den Aktoren verbaute Motoren müssen angesteuert werden, dazu verfolgt der Micro-Motor das Konzept von verteilten Ansteuerungen.</p>\n\n<p>An jedem Motor wird unmittelbar eine kompakte Micro-Motor Platine montiert, welche gleichzeitig auch einen Magnet-Encoder [1] optional beinhaltet.\nDiese Platine wird über einen einzigen Stecker mit Strom und CAN-Bus versorgt und kann eigenständig den Motor ansteuern.\nZusätzlich kann ein Endschalter ausgelesen werden und die Temperatur des Motors überwacht werden.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare PID-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten, welche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für AB-Encoder</li>\n  <li>optional Magnet-Encoder [1] auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, ADC, DAC, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardwareabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/odometrie.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Implementierung von odometrischer Positionsbestimmung und einer Kalibrierungs-Routine",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs benutzen bislang Odometrie zur eigenen Lokalisierung auf dem Spielfeld. Dabei wird\nkontinuierlich aus der Drehbewegung zweier Räder die Robotergeschwindigkeit berechnet und damit die Position\nnachgeführt.</p>\n\n<p>In Rahmen dieses Projektes soll zunächst der Code für die Positionsbestimmung per Odometrie neu entworfen und\nprogrammiert werden und anschließend eine Routine zur einfachen Kalibrierung der Odometrie-Parameter entwickelt werden.\nDie neue Software-Struktur soll die Integration weiterer Positionierungsmethoden vorsehen, etwa die Ultraschall-basierte\nabsolute Positionierung (vgl. Projekt Ultraschall Lokalisierung) oder eine Inertiale Messeinheit (IMU).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Einarbeitung in die Roboterkinematik</li>\n  <li>Entwurf von Algorithmen zur Positionierung und Kalibrierung</li>\n  <li>Programmierung für eingebettete Systeme in C++ mit XPCC/modm Framework</li>\n  <li>Programmierung einer grafischen Anwendung in Python3/PyQt5</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie mit optischer Sensorik",
          "category" : "Projekt",
          "tags"     : " elektronik, software, mechanik",
          "url"      : "/projekt/odometrie-maussensoren.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Entwicklung eines optische Odometriesystems [1] für Roboterantriebe.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für den sich in Entwicklung befindenden Antrieb des kleinen Roboters – basierend auf einem Omnidrive-Antrieb (siehe separate Projektbeschreibung) – kann keine konventionelle Odometrie mit zwei zusätzlichen nicht angetriebenen Rädern zur Positionsbestimmung genutzt werden.</p>\n\n<p>Ein vielversprechendes Konzept ist die Nutzung von Sensoren aus optischen Mäusen.</p>\n\n<p>Es gab im RCA bereits Versuche mit dem – inzwischen abgekündigten und nur noch schwer erhältlichen – Sensor ADNS9800 [2] von Avago.</p>\n\n<p>Idealerweise werden im Rahmen diese Projekts ein oder mehrere geeigneter Nachfolger ausfindig gemacht, die nötige Hardware aufgebaut, Software geschrieben und die Zuverlässig unter den Bedingungen des Eurobot-Wettbewerbs erprobt.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Latenz &lt;5ms</li>\n  <li>Auflösung X und Y: &lt;1mm</li>\n  <li>Auflösung Rotation: &lt;1° (ggf. mit mehreren Sensoren)</li>\n  <li>Kleine Bauform</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Recherche verfügbare Sensoren</li>\n  <li>Software</li>\n  <li>Testbench aufbauen</li>\n  <li>ggf. PCB Design</li>\n  <li>Datenanalyse und Aufbereitung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Roboter-Caddy",
          "category" : "Projekt",
          "tags"     : " mechanik, elektronik, software",
          "url"      : "/projekt/roboter-caddy.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Um die Roboter mit Zubehör, Baken, etc. bei den Wettbewerben zum Spielfeld zu transportieren wollen wir einen coolen Roboter-Caddy bauen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei Wettbewerben sind teils längere Distanzen zwischen Team-Bereich und Spielfeld mit dem Roboter und nötigem Zubehör zu überwinden. Ein Transportfahrzeug wäre als hilfreich.\nLangweilige Implementierungen dieser Idee kann man bei anderen Teams beobachten, wo die Roboter in Bollerwägen, Kisten oder Kinderwagen transportiert werden.</p>\n\n<p>Wir wollen das natürlich weniger langweilig haben, also mit einem Antrieb und Steuerung, welche den Roboter-Caddy im besten Fall autonom einer Person folgen lässt oder Fernsteuerung ermöglicht.</p>\n\n<h3 id=\"anforderungen\">Anforderungen</h3>\n<ul>\n  <li>Kompakte Bauform, leicht zu Wettbewerben zu transportieren\n    <ul>\n      <li>in Roboterkiste integriert</li>\n      <li>zusammenklappbar</li>\n      <li>o.ä.</li>\n    </ul>\n  </li>\n  <li>Robustes Fahrwerk für unebene Böden auf Wettbewerben</li>\n  <li>Leistungsstarker Antrieb</li>\n  <li>ggf. Fernsteuerung</li>\n  <li>ggf. Autonome Navigation</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Mechanik</li>\n  <li>Elektronik</li>\n  <li>Software</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Routing-Algorithmus",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/routing.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Entwicklung und Implementierung eines Routenfindungs-Algorithmus für die Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zur Navigation unserer Roboter auf dem Spielfeld soll ein Routing-Algorithmus entwickelt werden, mit dem jeder Roboter\nautonom die optimale Route zu einem Zielpunkt auf dem Spielfeld berechnen kann. Dabei sollen Hindernisse auf dem\nSpielfeld und nach Möglichkeit die aktuellen Positionen der anderen Roboter auf dem Feld mit Bezug auf die bekannten\nAußenmaße des Roboters berücksichtigt werden. Weiterhin sollte der Algorithmus die Einschränkungen des Antriebssystems\n(Bewegungs-Freiheitsgrade, max. Beschleunigung, etc.) berücksichtigen und möglichst einfach auf andere Antriebssysteme\n(z.B. Omnidrive) erweiterbar sein.</p>\n\n<h3 id=\"featuresideen\">Features/Ideen:</h3>\n<ul>\n  <li>A*-Algorithmus auf einem kartesischen Raster auf dem Spielfeld mit ca. 30mm Auflösung, je 8 Ausrichtungen,\n8 Bewegungsrichtungen pro Feld</li>\n  <li>Dynamische Berechnung von Kantengewichten basierend auf Richtungsänderungen und Antriebssystem</li>\n  <li>Vorabberechnung gesperrter Positionen/Ausrichtungen basierend auf Hindernissen und Roboterform</li>\n  <li>Online-Berechnung zusätzlich gesperrter Positionen/Ausrichtungen basierend auf Positionen anderer Roboter</li>\n  <li>Automatische Optimierung (Postprocessing) der Route durch Kurven und Geraden in beliebigen Winkeln</li>\n  <li>Ausführung auf einem separaten Microcontroller mit externem Speicher, Anbindung per CAN-Bus</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwicklung von Routing- und Geometrieverarbeitungs-Algorithmen</li>\n  <li>Ggf. Implementierung und Validierung von Algorithmus-Prototypen in Python o.ä.</li>\n  <li>Softwareentwicklung in C++ für Microcontroller</li>\n  <li>Integration in bestehende Robotersoftware mit modm.io und XPCC</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Sensorik zur Gewichtsmessung",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb, software, mechanik",
          "url"      : "/projekt/gewichtsmessung.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Aufbau eines Prototypen zur Gewichtsmessung von Spielelementen mit Roboterarmen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei der Ankündigung des Eurobot-Mottos für 2019 “Atom Factory” [1] wurde erwähnt, dass die Roboter Spielelemente wiegen sollen.\nAuch für einige andere Aktorik ist die Technologie hilfreich.</p>\n\n<p>Das Ziel des Projekts ist einen Prototyp einer Sensorik zur Gewichtsmessung für einen Roboterarm zu implementieren.</p>\n\n<p>Die verschiedenen möglichen Methoden zur Gewichtsmessung soll verglichen und für den Einsatz im Roboter bewertet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Mögliche Methoden\n    <ul>\n      <li>Strommessung Elektromotor</li>\n      <li>Dehnungsmessstreifen [2]</li>\n      <li>Mechanisch mit Feder und Taster</li>\n      <li>Weitere [3]</li>\n    </ul>\n  </li>\n  <li>Präzision je nach Anforderungen</li>\n  <li>Kraft/Gewicht je nach Anforderungen</li>\n  <li>Platine zum Anschluss an CAN</li>\n  <li>Kompakte Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Analoges Schaltungsdesign</li>\n  <li>PCB Design</li>\n  <li>STM32</li>\n  <li>Software Mikrocontroller</li>\n  <li>Ggf. Mechanik</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Silikon-Räder",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/silikon-raeder.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Silikon hat für die Antriebsräder sehr geeignete Eigenschaften.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs werden von Motoren angetrieben welche ihre Kraft mit Hilfe von Rädern auf den Untergrund bringen.</p>\n\n<p>Dabei spielen die Räder eine entscheidenden Faktor wie präzise und schnell der Roboter fahren, beschleunigen und bremsen kann.\nJe größer die Haftung der Räder auf dem Untergrund ist, umso besser kann Kraft übertragen werden.</p>\n\n<p>Historisch wurden im RCA modifizierte Inline-Skater-Räder oder Modellbau-Räder verwendet, in letzter Zeit hat uns die Firma TYP AG / TGW GmbH mit nach unseren Vorgaben individuell angefertigten Rädern mit vulkanisiertem Gummi unterstützt.</p>\n\n<p>Für den kleiner Roboter der Saison 2016 wurden bereits Experimente mit Silikonrädern durchgeführt, der Ergebnis war ein voller Erfolg.</p>\n\n<p>Im Rahmen dieses Projektes soll die Technologie zum Gießen von Silikon im RCA erarbeitet und dokumentiert werden und in Folge dessen für mindestens einen der Roboter Antriebs-Räder aus Silikon hergestellt werden.</p>\n\n<p>Neben den Antriebsrädern gibt es noch viele weitere Anwendungen für gegossene Silikon-Teile, beispielsweise bei Greifern.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Formen mit CNC-Fräse und/oder 3D-Drucker</li>\n  <li>Ggf. Kooperation mit einem Institut bzw. Silikonhersteller</li>\n  <li>Gießen von Silikon</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Simulator",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/simulator.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Im Simulator können die Roboter virtuell getestet werden, dazu wird die Roboterhardware emuliert und das Spielfeld mit Spielelementen sowie Gegnerroboter simuliert.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für das Testen von unserer Eurobot Spielstrategie wollen wir einen Simulator entwickeln,\nder den Roboter auf dem Spielfeld mit Spielelementen in 2 bis 2,5 Dimensionen simuliert,\nmit vereinfachten oder ideellen physikalischen Berechnungen.</p>\n\n<p>Dieser Simulator soll auch genutzt werden, um verschiedene Subsyteme des Roboters (zB. Regelungsschleifen, Sensorauswertungen mit Rauschen)\nwährend der Entwicklungsphase schnell zu testen, ohne auf einen funktionierenden Roboter angewiesen zu sein.\nInsbesondere zum Evaluieren unserer Spielstrategie ist es sinnvoll auch schneller als Echtzeit simulieren zu können.</p>\n\n<p>Desweiteren soll eine Anbindung an Matlab oder Numpy bereitstellt werden, sodass komplexere Simulationen von physikalischen \nEigenschaften als Plugin hinzugeschaltet werden können.\nDie Saison spezifischen Daten für das Spielfeld und Roboter können aus den Eurobot Shared Resources eingelesen werden [1].</p>\n\n<p>Der Zeitraum zwischen der Bekanntgabe der Eurobot-Regeln und den Wettbewerben ist mit einem halben Jahr recht kurz,\ndaher soll die Software-Entwicklung parallel zur Konstruktion und Bau der Mechanik erfolgen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Softwareentwicklung in Python oder C++ mit Qt5</li>\n  <li>Simulation von Robotern, Spielfeld und Spielelementen</li>\n  <li>Datenverarbeitung und Replay</li>\n  <li>Sensoren (Distanz, Laserscanner, Farbe, etc.)</li>\n  <li>Interface mit Matlab für Regelungen modellieren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Software auf modm portieren",
          "category" : "Projekt",
          "tags"     : " software, werkzeug",
          "url"      : "/projekt/rca-projekte-auf-modm-portieren.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Erstellung einer Skripte-Sammlung, die das Portieren unserer Software Projekte vom xpcc.io Framework zur modm.io Library (halb-)automatisch ermöglicht.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir nutzen seit 2009 das xpcc.io Framework [1] als Basis für all unsere eingebettete Software.\nVon 2016 bis 2018 haben die zwei Hauptmaintainer Fabian und Niklas H. dieses generalüberholt\nund tiefgreifende Änderungen in der Code-Generierung und teilweise der Struktur/API gemacht,\num den Code modularer und insbesondere unabhängig vom Build System zu machen.</p>\n\n<p>Der Nachfolger von xpcc heißt jetzt modm [2]. \nxpcc wird noch bis Ende 2018 maintained und danach als deprecated markiert.\nBis dahin werden alle Änderungen von xpcc nach modm von Niklas H. portiert.</p>\n\n<p>Ein oder mehrere Skripte sollen entwickelt werden, die den Hauptteil der Änderungen\nvollautomatisch, oder zumindest mit wenigen manuellen Eingriffen, anwenden.\nZusätzlich soll ein Porting Guide von xpcc auf modm für die Webseite geschrieben,\nsodass auch externe Anwender auf modm upgraden können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, Regex, Python3, SCons</li>\n  <li>Verständnis der Änderungen zwischen xpcc und modm</li>\n  <li>Code Generierung</li>\n  <li>Versionsverwaltung und CI</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Ultraschall Lokalisierung (Baken)",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/ultraschall-baken.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Unsere Roboter sollen sich mittels eines Ultraschall-Baken-Systems auf dem Spielfeld orientieren können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir wollen beim kommenden Wettbewerb ein neues System zu Lokalisierung und unserer eigenen sowie der Gegner-Roboter einsetzen.</p>\n\n<p>Das technische Konzept das Ultraschall-Lokalisierung wurde in den letzten Jahren bereits entwickelt und getestet, eine gute Übersicht liefert die Veröffentlichung [1].</p>\n\n<p>Dieses System muss nun in unsere Roboter und Gegner-Baken integriert, angepasst und getestet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Drei feste Baken am Spielfeldrand</li>\n  <li>Mobile Baken in den eigenen Robotern und in den Gegnerbaken</li>\n  <li>Geringe Latenz &lt;10ms</li>\n  <li>Genauigkeit &lt;5mm</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation mit R2MAC/NRF24L01+</li>\n  <li>Software\n    <ul>\n      <li>Portieren der Software zum modm-Framework</li>\n    </ul>\n  </li>\n  <li>ggf. PCB Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: librobots: Open Source Veröffentlichung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/librobots-open-source.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Vervollständigung und Veröffentlichung unserer internen librobots Bibliothek auf GitHub.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Es existiert recht viel Code, der jede Saison weiter benutzt wird, aber nicht \ngenerisch genug ist um in modm.io zu landen.\nDeshalb wurde angedacht, diesen Code in librobots zu überführen und dort als\neigenständiges Projekt zu warten und somit duplizierten Code zu vermeiden.\nDieses Projekt soll den Kern unserer modularen Robotersoftware werden, ähnlich\nwie xpcc bzw. modm der Kern unserer eingebetteten Software ist.\nDemzufolge soll auch die entstehende Architektur dokumentiert werden.</p>\n\n<p>Dieses Projekt ist als “Ausbildung” zum Open Source Maintainer gedacht, und ist\nsomit als Langzeitprojekt konzipiert.\nDie librobot soll zunächst im internen GitLab für die Veröffentlichung vorbereitet\nwerden und dann unter der RCA GitHub Organisation [1] als Open Source Projekt \ngeführt werden.\nDie Prozesse (Issue Tracking, Code Review, CI, Dokumentation) sollen wenn möglich\nähnlich zu modm.io gehalten werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Open Source Library Maintenance</li>\n  <li>Issue Tracking and Code Review</li>\n  <li>Architecture Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Besseres Dokumentationsformat",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, werkzeug",
          "url"      : "/projekt/modm-dokumentation.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Programmieren eines Dokutools mit Doxygen und lbuild Anbindung und Automatisierung von Doku-Qualitätkontrollen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Sowohl xpcc als auch modm [1] sind relativ gut <em>im Code</em> mittels Doxygen dokumentiert.\nFür xpcc haben wir somit einfach den generierten Doxygenoutput online gestellt [2].\nDoxygen eignet sich allerdings nicht besonders gut für Konzeptdokumentation und Beispielcode.</p>\n\n<p>Mit <code class=\"highlighter-rouge\">lbuild</code> [3] ist modm in mehrere Module aufgeteilt, die jeweils nur eine überschaubare Anzahl an Klassen verwalten.\nDiese Module können separat in Markdown dokumentiert werden und erlauben detailierte Konzeptdokumentation [4].\nDie Doxygendokumentation des Codes kann als XML ausgegeben und per Python3 eingelesen werden [5], momentan, werden\nallerdings nur die wichtigsten Objektnamen angezeigt [6].</p>\n\n<p>Es soll ein Konzept erarbeitet werden, wie am Besten die Doxygendokumentation in die Moduldokumentation eingebunden werden kann,\nsodass es einfach ist komplexe Dokumentation zu schreiben und mit der Implementation zu verlinken.\nDesweiteren sollen Beispiele in der Moduldokumentation kompilierbar sein, und wenn möglich weitere Überprüfungen (zB. valide Objektnamen im Fließtext) als Teil des CIs implementiert werden.\nDamit soll die Dokumentation synchron zur Implementierung gehalten werden.\nAbschließend soll diese Dokumentation visuell ansprechendend, durchsuchbar und gut navigierbar unter docs.modm.io automatisch\ndeployed werden.</p>\n\n<p>In Zukunft soll dieses Tool auch für librobots und evtl. andere RCA Projekte verwendet werden.\nAls Vorbild für Design und Vollständigkeit gilt die Qt5 Dokumentation [7].</p>\n\n<p><em>Es ist explizit nicht erforderlich, Dokumentation für modm zu schreiben!</em>\nEs geht hier um die automatische Erstellung und Pflege der Dokumentation, nicht unbedingt den Inhalt.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Doxygen XML Auswertung für Assembly, C, C++</li>\n  <li>Python3 und Jinja2 für Datenumwandlung und Dokumentationsgeneration</li>\n  <li>Editieren Technischer Dokumentation</li>\n  <li>Automatische Compilierung von Beispielcode</li>\n  <li>Automatisches Deployment der Dokumentation</li>\n  <li>Webdevelopment und -design, evtl. mit vorhandener Doku-Engine</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Einheitensystem und Festkomma-Arithmetik",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-units-and-fixed-point.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Implementation eines Einheitensystem mit user-defined literals und in Kombination mit Festkomma-Arithmetik für das open-source C++-Microcontroller-Framework modm.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für alle physikalischen Berechnungen in unserer Robotersoftware wollen wir Einheiten nutzen können, dies sorgt für übersichtlicheren und besser selbst-dokumentierenden Code.</p>\n\n<p>Beispiel:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>using namespace modm::units;\nlength_t distance = 300_mm;\ntime_t   time     = 1500_ms;\nvelocity_t speed  = distance / time;\nfloat foo         = distance + time; // compiler error: Units are not compatible.\n</code></pre></div></div>\n\n<p>Da es auf Microcontrollern aus verschiedenen Gründen nicht erstrebenswert mit Gleitkommazahlen zu rechnen ist, bietet es sich an gleichzeitig Festkomma-Arithmetik [1] im modm [2] zu implementieren.</p>\n\n<h3 id=\"diskussion--features\">Diskussion &amp; Features</h3>\n<ul>\n  <li>Fehlerabschätzung Multiplikation und Division</li>\n  <li>Unittests</li>\n  <li>Portieren und Anpassen bestehender Klassen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Hardware Unittests",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, elektronik, werkzeug",
          "url"      : "/projekt/modm-hwut.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Automatisches Ausführen von Unit- und Integrationstests auf Arm Cortex-M Mikrocontrollern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>modm [1] enthält eine große Anzahl an Unittests [2], die auch in unserem CI automatisch auf x86 ausgeführt werden.\nDiese Unittests können auch direkt auf dem Mikrocontroller ausgeführt werden, allerdings nur manuell und mit diversen Einschränkungen [3].\nDieser Prozess soll automatisiert werden, und die Ergebnisse als Teil des modm CIs für alle öffentlichen Pull Requests auf GitHub zur Verfügung gestellt werden.\nDazu stellen wir eine große Anzahl an diversen STM32 Discovery und Nucleo Development Boards.</p>\n\n<p>Da die modm Unittests recht begrenzt sind in ihrer Funktionalität, wäre es evtl. sinnvoll ein vollständigeres Unittest Framework wie Metal.Test zu nutzen [4].\nTracing und Performance könnte zusätzlich mit der Arm Cortex-M Debughardware erfasst werden [5].</p>\n\n<p>Zusätzlich zu in sich geschlossenen Unittests sollen auch Hardware Integrationstests erforscht werden.\nDazu gibt es Überlegungen, während eines Testes die Input/Output Werte des Mikrocontrollers mit Hilfe vom SigRok [6] zu erfassen und gegen diverse Eigenschaften und Testcases zu überprüfen.\nHier sollen verschiedene komplexe Tests gefahren und ausgewertet werden können [7], evtl. mit FPGA als IO-Multiplexer und Logikanalyzer.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Testing mit Hardware-in-Loop</li>\n  <li>Anzeige als GitHub Continuous Integration Service</li>\n  <li>Debugging mit GDB auf Arm Cortex-M</li>\n  <li>Arm Cortex-M Debug-Hardware</li>\n  <li>Erstellen von Logikwaveformtests</li>\n  <li>Automatisierte Auswertung von Logikprotokollanalysen</li>\n  <li>PCB Design mit FPGAs</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Konzept und Umsetzung einer DMA Schnittstelle",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-dma.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Erstellen eines Modells flexiblen und einfachen Nutzung von DMA (Direct Memory Access) in User-Code und anderen modm-Modulen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die meisten Mikrocontroller haben eine DMA-Einheit, welche unabhängig von der CPU auf Speicher zugreifen kann und Daten kopieren kann.\nDurch die Nutzung von DMA kann beispielsweise Peripherie wie SPI mit Daten zum senden versorgt und die empfangenen Daten gespeichert werden ohne dass die CPU hierbei belastet wird,\nwovon in modm [2] bisher kein Nutzen gemacht wird.</p>\n\n<p>Einige sehr zeitkritische Anwendungen können ohne DMA gar nicht implementiert werden,\nbeispielsweise eine Ansteuerung von WS2812-LEDs mit Bitmustern aus SPI.</p>\n\n<p>Im Rahmen dieses Projekts soll ein API für Abstraktion von DMA-Einheiten entwickelt werden welches sowohl flexibel im Bezug auf mögliche DMA-Einheiten ist,\nals auch universell in modm-Modulen wie Gerätetreibern und im User-Code einsetzbar ist.\nDie Abstraktion sollte mindestens für STM32 Mikrocontroller implementiert werden,\nweitere Implementierungen könnten später erfolgen.</p>\n\n<p>Anschließend können die vorhandene Treiber für STM32-Peripherie (SPI, UART, …) für DMA erweitert oder angepasst werden.</p>\n\n<p>Aus dem Vorgängerprojekt vom modm, xpcc, existiert eine DMA-API [1], die sich allerdings als suboptimal herausgestellt hat.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17</li>\n  <li>STM32 Speicherarchitektur, sowie weitere mögliche weitere Architekturen</li>\n  <li>STM32 Peripherie: DMA, Timer, SPI, UART, …</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Nebenläufigkeits Modelle erforschen (Concurrency)",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-concurrency-modelle.html",
          "date"     : "June 11, 2018",
          "excerpt"  : "Erstellen eines Modells zur einfachen und sicheren Beschreibung von Nebenläufigkeiten (Concurrency) für eingebettete Systeme.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Um die Nebenläufigkeiten im Robotercode zu beschreiben nutzen wir Protothreads [1], Resumable Functions [2] und Activities [3].\nDiese basieren auf sog. stackless cooperative scheduling, die simpelste Form der Nebenläufigkeit.\nDesweiteren ist das XPCC Protokoll als Event-Loop implementiert und ruft die Empfänger mittels diesen\nMechanismen auf [4].</p>\n\n<p>Diese Architektur ist sehr speichereffizient und funktioniert somit auch noch auf sehr speicherlimitierten\nMikrocontrollern wie die AVRs. Für unsere Zwecke ist sie aber zu effizient, sodass es mühsam und teilweise \nunintuitiv ist, komplexere Nebenläufigkeiten abzubilden. Desweiteren nutzen wir keine AVRs mehr, sondern\nARM Cortex-M Systeme, die genügend Speicher mitbringen.</p>\n\n<p>Wir möchten mehrere Concurrency Modelle erforschen und bewerten, wie gut sie sich auf\nunser Problem anwenden lassen und wie man sie effizient auf AVR und ARM Cortex-M\nimplementiert.</p>\n\n<p>Das Resultat soll dann in modm.io [5] implementiert werden und der Prozess ordentlich\ndokumentiert werden, sodass es auch extern genutzt werden kann.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, C11, AVR/ARMv6/v7-M Assembly</li>\n  <li>Concurrency Modelle: Actors, Threading, Coroutines, Event-Loops</li>\n  <li>AVR und ARM Cortex-M Architektur</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } 
   
  
]
